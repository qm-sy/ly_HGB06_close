C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ________
OBJECT MODULE PLACED IN .\output\温控程序.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE 温控程序.C LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\INC;..\温控程
                    -序-三路温控-modebus;..\温控程序-四路闭环温控-modebus) DEBUG OBJECTEXTEND OBJECT(.\output\温控程序.obj)

line level    source

   1          //  温制程序    2020-6-9
   2          //CPU STC15W4K32S4         11.0592Mhz
   3          
   4                                     
   5          
   6          #include  "STC15W4Kxx.H"
   7          #include <stdlib.h>
   8          #include "modbus.h"
   9          #include "intrins.H" 
  10          #include <stdio.h> 
  11          #include  <bin.c>
  12          #include "math.h"
  13          
  14          
  15          #define uchar  unsigned char
  16          #define uint   unsigned int
  17          #define ulong  unsigned long
  18          
  19          
  20          
  21          #define  Kp 8  //比例系数
  22          #define  Ki  0.5  //积分系数
  23          #define  Kd  2  //微分系数
  24          #define  PID_MAX  900
  25          #define  PID_MIN  0
  26          
  27          
  28          #define ADC_POWER   0x80            //ADC电源控制位
  29          #define ADC_FLAG    0x10            //ADC完成标志
  30          #define ADC_START   0x08            //ADC起始控制位
  31          #define ADC_SPEEDLL 0x00            //540个时钟
  32          #define ADC_SPEEDL  0x20            //360个时钟
  33          #define ADC_SPEEDH  0x40            //180个时钟
  34          #define ADC_SPEEDHH 0x60            //90个时钟
  35          
  36          #define CMD_IDLE    0               //空闲模式
  37          #define CMD_READ    1               //IAP字节读命令
  38          #define CMD_PROGRAM 2               //IAP字节编程命令
  39          #define CMD_ERASE   3               //IAP扇区擦除命令
  40          
  41          //#define ENABLE_IAP 0x80           //if SYSCLK<30MHz
  42          //#define ENABLE_IAP 0x81           //if SYSCLK<24MHz
  43          //#define ENABLE_IAP  0x82            //if SYSCLK<20MHz
  44          #define ENABLE_IAP 0x83           //if SYSCLK<12MHz
  45          //#define ENABLE_IAP 0x84           //if SYSCLK<6MHz
  46          //#define ENABLE_IAP 0x85           //if SYSCLK<3MHz
  47          //#define ENABLE_IAP 0x86           //if SYSCLK<2MHz
  48          //#define ENABLE_IAP 0x87           //if SYSCLK<1MHz
  49          
  50          
  51          //ID号的存放在程序区的地址为程序空间的最后7字节
  52          //#define ID_ADDR_ROM 0x03f9      //1K程序空间的MCU(如STC15F201EA, STC15F101EA)
  53          //#define ID_ADDR_ROM 0x07f9      //2K程序空间的MCU(如STC15F402EACS, STC15F202EA, STC15F102EA)
  54          //#define ID_ADDR_ROM 0x0bf9      //3K程序空间的MCU(如STC15F203EA, STC15F103EA)
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 2   

  55          //#define ID_ADDR_ROM 0x0ff9      //4K程序空间的MCU(如STC15F804EACS, STC15F404EACS, STC15F204EA, STC15F104
             -EA)
  56          //#define ID_ADDR_ROM 0x13f9      //5K程序空间的MCU(如STC15F205EA, STC15F105EA)
  57          //#define ID_ADDR_ROM 0x1ff9      //8K程序空间的MCU(如STC15F2K08S2,  STC15F808EACS, STC15F408EACS)
  58          //#define ID_ADDR_ROM 0x27f9      //10K程序空间的MCU(如STC15F410EACS)
  59          //#define ID_ADDR_ROM 0x2ff9      //12K程序空间的MCU(如STC15F812EACS, STC15F412EACS)
  60          //#define ID_ADDR_ROM 0x3ff9      //16K程序空间的MCU(如STC15F2K16S2, STC15F816EACS)
  61          //#define ID_ADDR_ROM 0x4ff9      //20K程序空间的MCU(如STC15F2K20S2, STC15F820EACS)
  62          //#define ID_ADDR_ROM 0x5ff9      //24K程序空间的MCU(如              STC15F824EACS)
  63          //#define ID_ADDR_ROM 0x6ff9      //28K程序空间的MCU(如              STC15F828EACS)
  64          #define ID_ADDR_ROM 0x7ff9      //32K程序空间的MCU(如STC15F2K32S2)
  65          //#define ID_ADDR_ROM 0x9ff9      //40K程序空间的MCU(如STC15F2K40S2)
  66          //#define ID_ADDR_ROM 0xbff9      //48K程序空间的MCU(如STC15F2K48S2)
  67          //#define ID_ADDR_ROM 0xcff9      //52K程序空间的MCU(如STC15F2K52S2)
  68          //#define ID_ADDR_ROM 0xdff9      //56K程序空间的MCU(如STC15F2K56S2)
  69          //#define ID_ADDR_ROM 0xeff9      //60K程序空间的MCU(如STC15F2K60S2)
  70          
  71          
  72          #define S1_S0 0x40              //P_SW1.6
  73          #define S1_S1 0x80              //P_SW1.7
  74          
  75          #define CCP_S0 0x10                 //P_SW1.4
  76          #define CCP_S1 0x20                 //P_SW1.5
  77          
  78          
  79          #define S2_S0 0x01              //P_SW2.0
  80          #define S3_S0 0x02              //P_SW2.1
  81          #define S4_S0 0x04              //P_SW2.2
  82          
  83          #define S2RI  0x01              //S2CON.0
  84          #define S2TI  0x02              //S2CON.1
  85          #define S2RB8 0x04              //S2CON.2
  86          #define S2TB8 0x08              //S2CON.3
  87          #define S2REN 0x10                          //S2CON.4
  88          
  89          #define S3RI  0x01              //S3CON.0
  90          #define S3TI  0x02              //S3CON.1
  91          #define S3RB8 0x04              //S3CON.2
  92          #define S3TB8 0x08              //S3CON.3
  93          
  94          #define S4RI  0x01              //S4CON.0
  95          #define S4TI  0x02              //S4CON.1
  96          #define S4RB8 0x04              //S4CON.2
  97          #define S4TB8 0x08              //S4CON.3
  98          
  99          #define PWM2345_S  0x10
 100          
 101          #define POLY        0x8005
 102          
 103          #define  nop    _nop_()
 104          
 105          #define CYCLE   12000    
 106          
 107          
 108            
 109          #define time_max  1450  
 110          
 111           /*
 112          #define   fd_key        3
 113          #define   mode_key      1
 114          #define   fn_key        2
 115          #define   power_key     5
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 3   

 116          #define   up_key        4
 117          #define   dn_key        0
 118          #define   fn_up_key     12
 119          #define   fn_dn_key     8
 120                     */
 121          
 122          #define   fd_key        2
 123          #define   mode_key      4
 124          #define   fn_key        3
 125          #define   power_key     0
 126          #define   up_key        1
 127          #define   dn_key        5
 128          #define   fn_up_key     9
 129          #define   fn_dn_key     13
 130          
 131          
 132          //************************************************************
 133          //485接收缓冲区
 134          unsigned char xdata g_recv_buffer[64];
 135          int xdata g_recv_buffer_index = 0;
 136          int xdata g_need_times = 10;            
 137          int xdata g_current_need_times = 0;     
 138          volatile unsigned char idata g_need_process_datas = 0;   
 139          
 140          uchar  idata  recv_cnt;
 141          
 142          //************************************************************
 143            
 144           int   idata last_error1;
 145           int   idata last_error2;
 146           int   idata last_error3;
 147           int   idata last_error4;
 148           int   idata last_error5;
 149           int   idata last_error6;
 150          
 151           float idata I_term1;
 152           float idata I_term2;
 153           float idata I_term3;
 154           float idata I_term4;
 155           float idata I_term5;
 156           float idata I_term6;
 157          
 158           int   idata  tm1_pwm;
 159           int   idata  tm2_pwm;
 160           int   idata  tm3_pwm;
 161           int   idata  tm4_pwm;
 162           int   idata  tm5_pwm;
 163           int   idata  tm6_pwm;
 164          
 165           int  idata  tmp_cnt1;
 166           int  idata  tmp_cnt2;
 167           int  idata  tmp_cnt3;
 168           int  idata  tmp_cnt4;
 169           int  idata  tmp_cnt5;
 170           int  idata  tmp_cnt6;
 171          
 172           bit   tm1_bit;
 173           bit   tm2_bit;
 174           bit   tm3_bit;
 175           bit   tm4_bit;
 176           bit   tm5_bit;
 177           bit   tm6_bit;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 4   

 178          
 179           bit   tm1_on_bit;
 180           bit   tm2_on_bit;
 181           bit   tm3_on_bit;
 182           bit   tm4_on_bit;
 183           bit   tm5_on_bit;
 184           bit   tm6_on_bit;
 185          
 186           bit   t1_work_bit;
 187           bit   t2_work_bit;
 188           bit   t3_work_bit;
 189           bit   t4_work_bit;
 190          
 191           bit hot_power_bit;
 192           bit mode_num_bit;
 193          
 194           uchar   hot_power;
 195           uchar   fan_power;
 196           uchar  idata   hot_in_data;
 197          
 198           uchar  idata  keybuf;
 199          
 200          
 201          
 202           uchar idata   key_buf;
 203                     
 204           uchar idata  t_cnt;
 205          
 206           uchar idata  fan_cnt;
 207          
 208           uchar idata  dis_temp_cnt;
 209           
 210           uchar idata  cnt3;
 211           uchar idata  cnt4;
 212           uchar idata  cnt5;
 213          
 214           uchar  idata  fan_close_cnt;
 215          
 216           uchar idata  ss_cnt;
 217          
 218           uchar idata  temp_num;
 219          
 220           uchar idata  temp_set_cnt;
 221           uchar idata  save_cnt;
 222           
 223           uint  idata  temp[7];
 224          
 225           uint  idata  pwm5;
 226          
 227           uint  idata  fan_pwm;
 228           uchar idata  fan_num;
 229          
 230           uchar idata  mode_num;
 231           uchar idata  fenduan_num;
 232           uchar idata  hot_num;
 233          
 234           int   idata  temp_set1;
 235           int   idata  temp_set2;
 236           int   idata  temp_set3;
 237           int   idata  temp_set4;
 238           int   idata  temp_set5;
 239           int   idata  temp_set6;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 5   

 240           
 241           uchar   xdata  tm_set1;
 242           uchar   xdata  tm_set2;
 243           uchar   xdata  tm_set3;
 244           uchar   xdata  tm_set4;
 245           uchar   xdata  tm_set5;
 246           uchar   xdata  tm_set6;
 247          
 248           int     idata  temp1;
 249           int     idata  temp2;
 250           int     idata  temp3;
 251           int     idata  temp4;
 252           int     idata  temp5;
 253           int     idata  temp6;
 254          
 255           uchar idata  tb_num;
 256          
 257           uchar idata  power_cnt;
 258          
 259           uchar  idata  mode_wr[10];     
 260           
 261          
 262          
 263           uchar idata lcd_03h; //显示地址缓存
 264           uchar idata lcd_06h; //显示地址缓存
 265           uchar idata lcd_07h; //显示地址缓存
 266           uchar idata lcd_0ah; //显示地址缓存
 267           uchar idata lcd_0bh; //显示地址缓存
 268           uchar idata lcd_0eh; //显示地址缓存
 269           uchar idata lcd_0fh; //显示地址缓存
 270           
 271           uint  idata  tm1;
 272           uint  idata  tm2;
 273           uint  idata  tm3;
 274           uint  idata  tm4;
 275           uint  idata  tm5;
 276           uint  idata  tm6;
 277          
 278                   
 279           unsigned long idata PeriodCnt = 0; 
 280           uchar  idata  HighRH = 0; 
 281           uchar  idata  HighRL = 0; 
 282           uchar  idata  LowRH = 0;
 283           uchar  idata  LowRL = 0; 
 284          
 285          
 286           uchar   xdata   ID_old[7];     
 287           uchar   xdata   ID_new[7]; 
 288           uchar   code    *cptr;
 289          
 290           unsigned char code Tab[]={
 291            0xF5,0x05,0xD3,0x97,0x27,0xB6,0xF6,0x15,
 292            0xF7,0xB7,0x77,0xE6,0xF0,0xC7,0xF2,0x72,       //0~F 代码
 293            0x00, //不显示
 294            0x02,//显示-
 295            };
 296          //----------------------------------------------------------------------------------
 297                                   
 298          sbit TM1722_DIO   = P3^7;
 299          sbit TM1722_CLK   = P4^1;
 300          sbit TM1722_STB   = P3^6;
 301          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 6   

 302           
 303          sbit hot_in=P0^7;  
 304          sbit hot_ok=P0^6;  
 305          sbit hot_fan=P0^5;  
 306          sbit lcd_bl=P2^0;  
 307          
 308          sbit led1=P4^4;
 309          sbit led2=P2^6;
 310          sbit led3=P4^3;
 311          sbit led4=P2^5;
 312          sbit led5=P4^2;
 313          sbit led6=P2^4;
 314          
 315          sbit out2=P2^1;
 316          
 317          sbit out3=P2^2;
 318          
 319          sbit out1=P1^7;
 320          
 321          sbit out4=P1^6;
 322          sbit out5=P2^7;
 323          sbit out6=P0^4;
 324          
 325          
 326          sbit speak=P5^4;
 327          //bit speak;
 328          
 329                                  
 330          bit uart_ok;
 331          bit sp_bit=1;
 332          bit clk_bit;
 333          
 334          bit zb_bit;
 335          
 336          bit dis_temp_bit;
 337          bit hot_HT_bit;
 338          
 339          bit  dis_HT_bit;
 340          bit  dis_ss_bit;
 341          
 342          bit save_bit;
 343          bit auto_bit;
 344          
 345          bit key_find_bit;
 346          bit temp_set_bit;
 347          bit ss_bit;
 348          
 349          bit power_bit;
 350          bit fan_bit;
 351          bit fan_bit2;
 352          bit fan_bit3;
 353          
 354           
 355          
 356          bit  PWMOUT;
 357          
 358          bit hot_fan_bit;
 359          
 360          bit fan_close_bit;
 361          bit fan_close_ok;
 362          bit tb_bit;
 363          bit fan_rs_bit;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 7   

 364          
 365          
 366          
 367          //****************************************************************************
 368          //      MF52E 10K at 25, B = 3950, ADC = 12 bits
 369          
 370          uint code temp_table[]={
 371          282     ,//0
 372          291     ,//1
 373          300     ,//2
 374          309     ,//3
 375          318     ,//4
 376          327     ,//5
 377          337     ,//6
 378          346     ,//7
 379          356     ,//8
 380          366     ,//9
 381          375     ,//10
 382          385     ,//11
 383          395     ,//12
 384          404     ,//13
 385          414     ,//14
 386          424     ,//15
 387          434     ,//16
 388          444     ,//17
 389          454     ,//18
 390          463     ,//19
 391          473     ,//20
 392          483     ,//21
 393          493     ,//22
 394          502     ,//23
 395          512     ,//24
 396          522     ,//25
 397          531     ,//26
 398          541     ,//27
 399          550     ,//28
 400          559     ,//29
 401          568     ,//30
 402          578     ,//31
 403          587     ,//32
 404          596     ,//33
 405          604     ,//34
 406          613     ,//35
 407          622     ,//36
 408          630     ,//37
 409          639     ,//38
 410          647     ,//39
 411          655     ,//40
 412          663     ,//41
 413          671     ,//42
 414          679     ,//43
 415          687     ,//44
 416          694     ,//45
 417          702     ,//46
 418          709     ,//47
 419          716     ,//48
 420          723     ,//49
 421          730     ,//50
 422          737     ,//51
 423          743     ,//52
 424          750     ,//53
 425          756     ,//54
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 8   

 426          763     ,//55
 427          769     ,//56
 428          775     ,//57
 429          781     ,//58
 430          786     ,//59
 431          792     ,//60
 432          797     ,//61
 433          803     ,//62
 434          808     ,//63
 435          813     ,//64
 436          818     ,//65
 437          823     ,//66
 438          828     ,//67
 439          833     ,//68
 440          837     ,//69
 441          842     ,//70
 442          846     ,//71
 443          850     ,//72
 444          854     ,//73
 445          858     ,//74
 446          862     ,//75
 447          866     ,//76
 448          870     ,//77
 449          874     ,//78
 450          877     ,//79
 451          881     ,//80
 452          884     ,//81
 453          888     ,//82
 454          891     ,//83
 455          894     ,//84
 456          897     ,//85
 457          900     ,//86
 458          903     ,//87
 459          906     ,//88
 460          909     ,//89
 461          911     ,//90
 462          914     ,//91
 463          917     ,//92
 464          919     ,//93
 465          921     ,//94
 466          924     ,//95
 467          926     ,//96
 468          928     ,//97
 469          931     ,//98
 470          933     ,//99
 471          935     ,//100
 472          937     ,//101
 473          939     ,//102
 474          941     ,//103
 475          943     ,//104
 476          945     ,//105
 477          946     ,//106
 478          948     ,//107
 479          950     ,//108
 480          952     ,//109
 481          953     ,//110
 482          955     ,//111
 483          956     ,//112
 484          958     ,//113
 485          959     ,//114
 486          961     ,//115
 487          962     ,//116
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 9   

 488          964     ,//117
 489          965     ,//118
 490          966     ,//119
 491          967     //120
 492          };
 493                   
 494          //_________________________________________________________________________
 495          
 496            
 497          //*******************************************************************************
 498          
 499          
 500          uchar ID_read_ok(void)
 501          {
 502   1       uchar i;
 503   1       cptr = ID_ADDR_ROM;         
 504   1          for (i=0; i<7; i++)        
 505   1          {
 506   2             ID_old[i]= *cptr++;      
 507   2          }
 508   1        
 509   1        ID_old[0]=((ID_old[0]+15)*5/4)<<7;    
 510   1        ID_old[1]=((ID_old[1]+15)*5/4)<<7;
 511   1        ID_old[2]=((ID_old[2]+15)*5/4)<<7;
 512   1        ID_old[3]=((ID_old[3]+15)*5/4)<<7;
 513   1        ID_old[4]=((ID_old[4]+15)*5/4)<<7;
 514   1        ID_old[5]=((ID_old[5]+15)*5/4)<<7;
 515   1        ID_old[6]=((ID_old[6]+15)*5/4)<<7;
 516   1      
 517   1       cptr = 0x5000;        
 518   1          for (i=0; i<7; i++)        
 519   1          {
 520   2             ID_new[i]= *cptr++;     
 521   2          } 
 522   1      
 523   1      
 524   1       for (i=0; i<7; i++){
 525   2                                    if(ID_old[i]!=ID_new[i])  return 1;  
 526   2      
 527   2                           }
 528   1       return 0;       
 529   1      
 530   1      }
 531          
 532          
 533          /********************  计算温度 ***********************************************/
 534          // 计算结果: 0对应-40.0度, 400对应0度, 625对应25.0度, 最大1600对应120.0度. 
 535          // 为了通用, ADC输入为12bit的ADC值.
 536          // 电路和软件算法设计: Coody
 537          /**********************************************/
 538                           
 539          
 540          uint get_temperature(uint adc)
 541          {
 542   1              uint    code *p;
 543   1              uint    i;
 544   1              uchar   j,k,min,max;
 545   1              
 546   1              //adc = 4096 - adc;     //Rt接地
 547   1              p = temp_table;
 548   1              //if(adc < p[0])                return (0xfffe);
 549   1              //if(adc > p[160])      return (0xffff);
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 10  

 550   1                      
 551   1              min = 0;                //0度
 552   1              max = 120;              //120度
 553   1      
 554   1              for(j=0; j<5; j++)      
 555   1              {
 556   2                      k = min / 2 + max / 2;
 557   2                      if(adc <= p[k]) max = k;
 558   2                      else                    min = k;
 559   2              }
 560   1                       if(adc == p[min])      i = min;
 561   1              else if(adc == p[max])  i = max;
 562   1              else    // min < temp < max
 563   1              {
 564   2                      while(min <= max)
 565   2                      {
 566   3                              min++;
 567   3                              if(adc == p[min])       {i = min;       break;}
 568   3                              else if(adc < p[min])
 569   3                              {
 570   4                                      min--;
 571   4                                      //i = p[min];   //min
 572   4                                      //j = (adc - i) * D_SCALE / (p[min+1] - i);
 573   4                                      i = min;
 574   4                                      //i *= D_SCALE;
 575   4                                      //i += j;
 576   4                                      break;
 577   4                              }
 578   3                      }
 579   2              }
 580   1              return i;
 581   1      }
 582                   
 583          
 584          //************************************************************************
 585          
 586          void Delay1ms(unsigned int dd)          //@11.0592MHz
 587          {
 588   1              unsigned char i, j;
 589   1        while(dd){
 590   2                          _nop_();
 591   2                          _nop_();
 592   2                          _nop_();
 593   2                       i = 11;
 594   2                       j = 190;
 595   2                       do
 596   2                         {
 597   3                              while (--j);
 598   3                         } while (--i);
 599   2      
 600   2                           WDT_CONTR=0X34;
 601   2                               dd--;
 602   2                  }
 603   1      }
 604          
 605          
 606          
 607          //*****************************************************************************
 608          
 609          
 610          void UartInit(void)             //9600bps@11.0592MHz
 611          {
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 11  

 612   1              SCON = 0x50;            //8位数据,可变波特率 串口1
 613   1      
 614   1              //S3CON = 0x10;         //8位数据,可变波特率
 615   1              //S3CON &= 0xBF;                //串口3选择定时器2为波特率发生器
 616   1      
 617   1              //S4CON = 0x10;         //8位数据,可变波特率
 618   1              //S4CON &= 0xBF;                //串口4选择定时器2为波特率发生器
 619   1      
 620   1          AUXR |= 0x01;               //串口1选择定时器2为波特率发生器
 621   1              AUXR |= 0x04;           //定时器2时钟为Fosc,即1T
 622   1              T2L = 0xE0;             //设定定时初值
 623   1              T2H = 0xFE;             //设定定时初值
 624   1              AUXR |= 0x10;           //启动定时器2
 625   1              RI=0;
 626   1              TI=0;
 627   1          ES=1;
 628   1              //S3CON &= ~S3RI;
 629   1              //S4CON &= ~S4RI;
 630   1              //IE2 = 0x08;     //打开串口3中断
 631   1              
 632   1      }
 633                            
 634          
 635          void Timer0Init(void)           //1毫秒@11.0592MHz
 636          {
 637   1              AUXR |= 0x80;           //定时器时钟1T模式
 638   1              TMOD &= 0xF0;           //设置定时器模式
 639   1              TL0 = 0xCD;             //设置定时初值
 640   1              TH0 = 0xD4;             //设置定时初值
 641   1              TF0 = 0;                //清除TF0标志
 642   1              TR0 = 1;                //定时器0开始计时
 643   1              ET0=1;
 644   1      }
 645          
 646          
 647          
 648          
 649          void Timer3Init(void)           //50毫秒@11.0592MHz
 650          {
 651   1              T4T3M &= 0xFD;          //定时器时钟12T模式
 652   1              T3L = 0x00;             //设置定时初值
 653   1              T3H = 0x4C;             //设置定时初值
 654   1              T4T3M |= 0x08;          //定时器3开始计时
 655   1              IE2 |= 0x20;       //开定时器3中断
 656   1      }
 657          
 658          
 659          
 660          
 661          
 662          
 663          /*----------------------------------------------------------------------------
 664          关闭IAP
 665          ----------------------------*/
 666          void IapIdle()
 667          {
 668   1          IAP_CONTR = 0;                 
 669   1          IAP_CMD = 0;                   
 670   1          IAP_TRIG = 0;                   
 671   1          IAP_ADDRH = 0x80;              
 672   1          IAP_ADDRL = 0;
 673   1      }
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 12  

 674          
 675          /*----------------------------
 676          从ISP/IAP/EEPROM区域读取一字节
 677          ----------------------------*/
 678          uchar IapReadByte(uint addr)
 679          {
 680   1          uchar dat;                       //数据缓冲区
 681   1      
 682   1          IAP_CONTR = ENABLE_IAP;         
 683   1          IAP_CMD = CMD_READ;             
 684   1          IAP_ADDRL = addr;              
 685   1          IAP_ADDRH = addr >> 8;         
 686   1          IAP_TRIG = 0x5a;                
 687   1          IAP_TRIG = 0xa5;               
 688   1          _nop_();                        
 689   1          dat = IAP_DATA;                 
 690   1          IapIdle();                     
 691   1      
 692   1          return dat;                     
 693   1      }
 694          
 695          /*----------------------------
 696          写一字节数据到ISP/IAP/EEPROM区域
 697          ----------------------------*/
 698          void IapProgramByte(uint addr, uchar dat)
 699          {
 700   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 701   1          IAP_CMD = CMD_PROGRAM;          //设置IAP命令
 702   1          IAP_ADDRL = addr;               //设置IAP低地址
 703   1          IAP_ADDRH = addr >> 8;          //设置IAP高地址
 704   1          IAP_DATA = dat;                 //写ISP/IAP/EEPROM数据
 705   1          IAP_TRIG = 0x5a;                //写触发命令(0x5a)
 706   1          IAP_TRIG = 0xa5;                //写触发命令(0xa5)
 707   1          _nop_();                        //等待ISP/IAP/EEPROM操作完成
 708   1          IapIdle();
 709   1      }
 710          
 711          /*----------------------------
 712          扇区擦除
 713          ----------------------------*/
 714          void IapEraseSector(uint addr)
 715          {
 716   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 717   1          IAP_CMD = CMD_ERASE;            //设置IAP命令
 718   1          IAP_ADDRL = addr;               //设置IAP低地址
 719   1          IAP_ADDRH = addr >> 8;          //设置IAP高地址
 720   1          IAP_TRIG = 0x5a;                //写触发命令(0x5a)
 721   1          IAP_TRIG = 0xa5;                //写触发命令(0xa5)
 722   1          _nop_();                        //等待ISP/IAP/EEPROM操作完成
 723   1          IapIdle();
 724   1      }
 725          
 726          //******************************************************************
 727                  
 728          void save_mode_num(void)   
 729          {
 730   1       uint addr;
 731   1       
 732   1       addr=0x0000;
 733   1       EA=0;
 734   1       IapEraseSector(addr);   
 735   1      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 13  

 736   1       IapProgramByte(addr,mode_num); 
 737   1       
 738   1                     
 739   1       EA=1;
 740   1      }
 741          
 742          
 743          void fan_close_save(void)
 744          {
 745   1       uint addr;
 746   1       
 747   1       addr=0x1000;
 748   1       EA=0;
 749   1       IapEraseSector(addr);    
 750   1      
 751   1       IapProgramByte(addr,fan_close_cnt); 
 752   1       
 753   1                     
 754   1       EA=1;
 755   1      
 756   1      }
 757          
 758          
 759          
 760          
 761          
 762          void hot_power_save(void)  
 763          {
 764   1       uint addr;
 765   1       
 766   1       addr=0x1200;
 767   1       EA=0;
 768   1       IapEraseSector(addr);   
 769   1      
 770   1       IapProgramByte(addr,hot_power); 
 771   1       
 772   1                     
 773   1       EA=1;
 774   1      
 775   1      }
 776          
 777          
 778          void fan_power_save(void)  
 779          {
 780   1       uint addr;
 781   1       
 782   1       addr=0x1400;
 783   1       EA=0;
 784   1       IapEraseSector(addr);   
 785   1      
 786   1       IapProgramByte(addr,fan_power); 
 787   1       
 788   1                     
 789   1       EA=1;
 790   1      
 791   1      }
 792          
 793          
 794          void fan_close_read(void) 
 795          {
 796   1       uint addr;
 797   1       
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 14  

 798   1       addr=0x1000;
 799   1       EA=0;
 800   1       fan_close_cnt=IapReadByte(addr);
 801   1       EA=1;
 802   1      
 803   1       if((fan_close_cnt<10)||(fan_close_cnt>250))      fan_close_cnt=120;
 804   1      }
 805          
 806          
 807          void hot_power_read(void) 
 808          {
 809   1       uint addr;
 810   1       
 811   1       addr=0x1200;
 812   1       EA=0;
 813   1       hot_power=IapReadByte(addr);
 814   1       EA=1;
 815   1      
 816   1       if(hot_power>1)    hot_power=0;
 817   1                                                                      
 818   1      }
 819          
 820          
 821          
 822          void fan_power_read(void) 
 823          {
 824   1       uint addr;
 825   1       
 826   1       addr=0x1400;
 827   1       EA=0;
 828   1       fan_power=IapReadByte(addr);
 829   1       EA=1;
 830   1      
 831   1       if(fan_power>1)    fan_power=0;
 832   1                                                                      
 833   1      }
 834          
 835          //**********************************************************
 836          void  read_mode_wr_data(void) 
 837          {
 838   1       fenduan_num=mode_wr[0]; 
 839   1       tb_num=mode_wr[1];         
 840   1       fan_num=mode_wr[2];    
 841   1       hot_num=mode_wr[3];    
 842   1      
 843   1       tm_set1=mode_wr[4];
 844   1       tm_set2=mode_wr[5];
 845   1       tm_set3=mode_wr[6];    
 846   1       tm_set4=mode_wr[7];    
 847   1       tm_set5=mode_wr[8];    
 848   1       tm_set6=mode_wr[9];    
 849   1      
 850   1       if((fenduan_num==0)||(fenduan_num>7))  fenduan_num=1;
 851   1       if(tb_num>1)       tb_num=0; 
 852   1       if(fan_num>6)      fan_num=0;
 853   1       if(hot_num>100)    hot_num=50;
 854   1      
 855   1       if(tm_set1>200)        tm_set1=40;
 856   1       if(tm_set2>200)        tm_set2=40;
 857   1       if(tm_set3>200)        tm_set3=40;
 858   1       if(tm_set4>200)        tm_set4=40;
 859   1       if(tm_set5>200)        tm_set5=40;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 15  

 860   1       if(tm_set6>200)        tm_set6=40;
 861   1      
 862   1      }
 863          
 864          
 865          void  save_mode_wr(void)
 866          {
 867   1       uchar n;
 868   1       uint addr;
 869   1      
 870   1       mode_wr[0]=fenduan_num; 
 871   1       mode_wr[1]=tb_num;          
 872   1       mode_wr[2]=fan_num;    
 873   1       mode_wr[3]=hot_num;    
 874   1      
 875   1       mode_wr[4]=tm_set1;    
 876   1       mode_wr[5]=tm_set2;    
 877   1       mode_wr[6]=tm_set3;    
 878   1       mode_wr[7]=tm_set4;    
 879   1       mode_wr[8]=tm_set5;    
 880   1       mode_wr[9]=tm_set6;    
 881   1      
 882   1       if(mode_num==1) 
 883   1         {
 884   2          addr=0x0200;
 885   2              EA=0;
 886   2              IapEraseSector(addr);    
 887   2          for(n=0;n<10;n++) {IapProgramByte(addr,mode_wr[n]); addr++;}
 888   2              EA=1;
 889   2         }
 890   1      
 891   1       else if(mode_num==2) 
 892   1         {
 893   2          addr=0x0400;
 894   2              EA=0;
 895   2              IapEraseSector(addr);    
 896   2          for(n=0;n<10;n++) {IapProgramByte(addr,mode_wr[n]); addr++;}
 897   2              EA=1;
 898   2         }
 899   1      
 900   1       else if(mode_num==3) 
 901   1         {
 902   2          addr=0x0600;
 903   2              EA=0;
 904   2              IapEraseSector(addr);    
 905   2          for(n=0;n<10;n++) {IapProgramByte(addr,mode_wr[n]); addr++;}
 906   2              EA=1;
 907   2         }
 908   1      
 909   1       else if(mode_num==4) 
 910   1         {
 911   2          addr=0x0800;
 912   2              EA=0;
 913   2              IapEraseSector(addr);    
 914   2          for(n=0;n<10;n++) {IapProgramByte(addr,mode_wr[n]); addr++;}
 915   2              EA=1;
 916   2         }
 917   1      
 918   1       else if(mode_num==5) 
 919   1         {
 920   2          addr=0x0a00;
 921   2              EA=0;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 16  

 922   2              IapEraseSector(addr);    
 923   2          for(n=0;n<10;n++) {IapProgramByte(addr,mode_wr[n]); addr++;}
 924   2              EA=1;
 925   2         }
 926   1      }
 927          
 928          
 929          void read_mode(void)
 930          {
 931   1       uint addr;
 932   1       EA=0;
 933   1       addr=0x0000;
 934   1       mode_num=IapReadByte(addr);
 935   1       
 936   1       EA=1;
 937   1      
 938   1      
 939   1       }
 940          
 941            
 942          void read_data(void)
 943          {
 944   1       uint addr;
 945   1       uchar n;
 946   1      
 947   1       if((mode_num==0)||(mode_num>3)) {mode_num=1;}
 948   1      
 949   1       if(mode_num==1) 
 950   1         {
 951   2              EA=0;
 952   2              addr=0x0200;
 953   2          for(n=0;n<10;n++) {mode_wr[n]=IapReadByte(addr);    addr++;}
 954   2              EA=1;
 955   2         }
 956   1      
 957   1       else if(mode_num==2) 
 958   1         {
 959   2              EA=0;
 960   2              addr=0x0400;
 961   2          for(n=0;n<10;n++) {mode_wr[n]=IapReadByte(addr);    addr++;}
 962   2              EA=1;
 963   2         }
 964   1      
 965   1       else if(mode_num==3) 
 966   1         {
 967   2              EA=0;
 968   2              addr=0x0600;
 969   2          for(n=0;n<10;n++) {mode_wr[n]=IapReadByte(addr);    addr++;}
 970   2              EA=1;
 971   2         }
 972   1      
 973   1       else if(mode_num==4) 
 974   1         {
 975   2              EA=0;
 976   2              addr=0x0800;
 977   2          for(n=0;n<10;n++) {mode_wr[n]=IapReadByte(addr);    addr++;}
 978   2              EA=1;
 979   2         }
 980   1      
 981   1       else if(mode_num==5) 
 982   1         {
 983   2              EA=0;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 17  

 984   2              addr=0x0a00;
 985   2          for(n=0;n<10;n++) {mode_wr[n]=IapReadByte(addr);    addr++;}
 986   2              EA=1;
 987   2         }
 988   1      
 989   1       read_mode_wr_data();  
 990   1       
 991   1      
 992   1      
 993   1      
 994   1      }
 995          
 996                  
 997          
 998          
 999          
1000          //__________________________________________________________________________
1001          
1002          
1003          //***********************************************************************
1004          
1005          void InitADC(void)
1006          {
1007   1          P1ASF = B0011_1111;                   
1008   1          ADC_RES = 0;                   
1009   1          ADC_RESL=0;
1010   1          ADC_CONTR = ADC_POWER | ADC_SPEEDL;
1011   1         
1012   1      }
1013          
1014          
1015          
1016          //----------------------------
1017          uint GetADCResult(uchar ch)     
1018          {
1019   1       uint dd=0;
1020   1      
1021   1          ADC_CONTR = ADC_POWER | ADC_SPEEDL | ch | ADC_START;
1022   1          _nop_();                       
1023   1          _nop_();
1024   1          _nop_();
1025   1          _nop_();
1026   1          while (!(ADC_CONTR & ADC_FLAG));
1027   1          ADC_CONTR &= ~ADC_FLAG;        
1028   1      
1029   1          dd= ADC_RES;                
1030   1          dd=dd<<2;
1031   1          dd=dd|ADC_RESL;
1032   1              return dd;
1033   1      }
1034           
1035          
1036          
1037          uint Temperature_LPF(uchar ch)
1038          {
1039   1       uint a;
1040   1       uchar i,j,k;
1041   1       for(i=0;i<=6;i++)
1042   1        {
1043   2          temp[i]= GetADCResult(ch); 
1044   2          Delay1ms(2);
1045   2        }
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 18  

1046   1       for(j=0;j<=6;j++)
1047   1        {                      
1048   2          for(k=j;k<=6;k++)
1049   2               {
1050   3             if(temp[j]>=temp[k])
1051   3                   {
1052   4                 a=temp[j];
1053   4                 temp[j]=temp[k];
1054   4                 temp[k]=a;
1055   4                }
1056   3            }
1057   2         }
1058   1       temp[0]=temp[6]=0;
1059   1      
1060   1      return (temp[1]+temp[2]+temp[3]+temp[4]+temp[5])/5; 
1061   1      
1062   1      }
1063          
1064          
1065          
1066          /*
1067          
1068          float Get_Tempture(uint adc)
1069          {
1070                  float RV,RT,Tmp;
1071                  RV=BaseVol/1024.0*(float)adc;//ADC为10位ADC,求出NTC电压:RV=ADCValu/1024*BaseVoltag
1072                  RT=RV*10/RV;//(BaseVol-RV);//求出当前温度阻值 (BaseVoltage-RV)/R16=RV/RT;
1073                  Tmp=1/(1/TN+(log(RT/RN)/B))-273.15;//%RT = RN exp*B(1/T-1/TN)%
1074                   return Tmp;
1075          }
1076            */
1077          
1078          
1079          
1080          
1081          
1082          void send_buffer(unsigned char *buf,int len)
1083          {       
1084   1              while (len--) {
1085   2                      TI=0;     //Clear transmit interrupt flag
1086   2                      SBUF = *buf++;
1087   2                      while (TI == 0);
1088   2                      TI=0;
1089   2              }
1090   1      }
1091           
1092          
1093          
1094          
1095          //*********************************************************************
1096          
1097          
1098          void Delay50us(void)            //@11.0592MHz
1099          {
1100   1              unsigned char i, j;
1101   1         
1102   1              _nop_();
1103   1              i = 1;
1104   1              j = 134;
1105   1              do
1106   1              {
1107   2                      while (--j);
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 19  

1108   2              } while (--i);
1109   1       
1110   1      }
1111                             
1112          
1113          
1114                                                            
1115                        
1116          
1117          /******************************************
1118          函数：写一字节函数
1119          参数：dat---写入的一字节数据
1120          返回值：无
1121          ******************************************/
1122          void TM1722_Write_Byte(unsigned char dat)
1123          {
1124   1        unsigned char i;
1125   1               
1126   1        Delay50us(); 
1127   1        TM1722_STB=0;     
1128   1        for(i=0;i<8;i++)
1129   1        {
1130   2         TM1722_CLK=0;
1131   2         TM1722_DIO=dat&0x01;
1132   2         TM1722_CLK=1;    
1133   2         dat>>=1;      
1134   2        }
1135   1        Delay50us();   
1136   1      }
1137          
1138          
1139          
1140          
1141          
1142          
1143          /******************************************
1144          函数：写一位数码管函数
1145          参数：num_addr---数码管位，num---显示数字数据
1146          返回值：无
1147          ******************************************/
1148          void TM1722_Write_Word(uchar num_addr,uchar num)
1149          {
1150   1        uchar temp1,temp2;
1151   1        uchar addr1;
1152   1        uchar addr2;
1153   1      
1154   1        if(num_addr==1)       {addr1=0xcb;  addr2=0xca;  lcd_0bh=lcd_0bh&B1111_0000; lcd_0bh=temp1=lcd_0bh|(Tab[
             -num]&0xf0)>>4;  lcd_0ah=lcd_0ah&B1111_0000; lcd_0ah=temp2=lcd_0ah|(Tab[num]&0x0f);}
1155   1        else if(num_addr==2)  {addr1=0xc7;  addr2=0xc7;  lcd_07h=lcd_07h&B0000_1000; lcd_07h=temp2=lcd_07h|Tab[n
             -um];}
1156   1        else if(num_addr==3)  {addr1=0xc6;  addr2=0xc6;  lcd_06h=lcd_06h&B0000_1000; lcd_06h=temp2=lcd_06h|Tab[n
             -um];}
1157   1       
1158   1      
1159   1      
1160   1        TM1722_STB=1;            //端口配置初始化
1161   1        TM1722_CLK=1;
1162   1        TM1722_DIO=1;
1163   1        TM1722_Write_Byte(0x00); 
1164   1        TM1722_STB=1;
1165   1        TM1722_Write_Byte(0x44);   
1166   1        TM1722_STB=1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 20  

1167   1      
1168   1        if(num_addr!=1) goto  next_num1;
1169   1         
1170   1        TM1722_Write_Byte(addr1);//显示寄存器的00H单元开始
1171   1        TM1722_Write_Byte(temp1);     //给显示寄存器送数据，
1172   1        TM1722_STB=1;  
1173   1      
1174   1        next_num1: nop;
1175   1      
1176   1        TM1722_Write_Byte(addr2);//显示寄存器的00H单元开始
1177   1        TM1722_Write_Byte(temp2);     //给显示寄存器送数据，
1178   1        TM1722_STB=1;
1179   1      
1180   1        TM1722_Write_Byte(0x93); //显示开
1181   1        TM1722_STB=1;
1182   1        
1183   1      }   
1184           
1185          
1186          void fan_dis(uchar num)   
1187          {
1188   1        if(num==0)       {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B0000_0000; }
1189   1        else if(num==1)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B0100_0000; }
1190   1        else if(num==2)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_0000; }
1191   1        else if(num==3)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1000; }
1192   1        else if(num==4)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1100; }
1193   1        else if(num==5)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1110; }
1194   1        else if(num==6)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1111; }
1195   1      
1196   1        TM1722_STB=1;           
1197   1        TM1722_CLK=1;
1198   1        TM1722_DIO=1;
1199   1        TM1722_Write_Byte(0x00); //工作模式
1200   1        TM1722_STB=1;
1201   1        TM1722_Write_Byte(0x44);   //固定地址模式
1202   1        TM1722_STB=1;
1203   1       
1204   1      
1205   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1206   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1207   1        TM1722_STB=1;
1208   1      
1209   1        TM1722_Write_Byte(0x93); 
1210   1        TM1722_STB=1;
1211   1        
1212   1      }   
1213          
1214          
1215          
1216          
1217          
1218          
1219          
1220          
1221          
1222          void lcd_clear(uchar dat) 
1223          {
1224   1      
1225   1        lcd_03h=dat;
1226   1        lcd_06h=dat;
1227   1        lcd_07h=dat;
1228   1        lcd_0ah=dat;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 21  

1229   1        lcd_0bh=dat;
1230   1        lcd_0eh=dat;
1231   1        lcd_0fh=dat;
1232   1      
1233   1        TM1722_STB=1;            //端口配置初始化
1234   1        TM1722_CLK=1;
1235   1        TM1722_DIO=1;
1236   1        TM1722_Write_Byte(0x00); 
1237   1        TM1722_STB=1;
1238   1        TM1722_Write_Byte(0x44);   
1239   1        TM1722_STB=1;
1240   1      
1241   1                                                              
1242   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1243   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1244   1        TM1722_STB=1;
1245   1      
1246   1        TM1722_Write_Byte(0xc6);         //显示寄存器的00H单元开始
1247   1        TM1722_Write_Byte(lcd_06h);     //给显示寄存器送数据，
1248   1        TM1722_STB=1;
1249   1      
1250   1        TM1722_Write_Byte(0xc7);         //显示寄存器的00H单元开始
1251   1        TM1722_Write_Byte(lcd_07h);     //给显示寄存器送数据，
1252   1        TM1722_STB=1;
1253   1      
1254   1        TM1722_Write_Byte(0xca);         //显示寄存器的00H单元开始
1255   1        TM1722_Write_Byte(lcd_0ah);     //给显示寄存器送数据，
1256   1        TM1722_STB=1;
1257   1      
1258   1      
1259   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1260   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1261   1        TM1722_STB=1;
1262   1      
1263   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1264   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1265   1        TM1722_STB=1;
1266   1      
1267   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1268   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1269   1        TM1722_STB=1;
1270   1      
1271   1        TM1722_Write_Byte(0x93); 
1272   1        TM1722_STB=1;
1273   1      
1274   1      }
1275          
1276          
1277          
1278          void  dis1(bit sss,uint ss)    
1279          {
1280   1       uchar a1,a2,a3;
1281   1       if(sss)
1282   1         {
1283   2          a1=ss%1000/100;
1284   2          a2=ss%100/10;
1285   2          a3=ss%10;
1286   2      
1287   2               if(a1==0) TM1722_Write_Word(1,16);
1288   2           else      TM1722_Write_Word(1,a1);
1289   2      
1290   2               if((a1==0)&&(a2==0)) TM1722_Write_Word(2,16);
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 22  

1291   2           else                 TM1722_Write_Word(2,a2); 
1292   2                
1293   2           TM1722_Write_Word(3,a3); 
1294   2          
1295   2         }
1296   1       else
1297   1        {
1298   2           TM1722_Write_Word(1,16);  
1299   2           TM1722_Write_Word(2,16);  
1300   2           TM1722_Write_Word(3,16); 
1301   2           
1302   2         }
1303   1      
1304   1      }
1305          
1306          
1307          
1308          
1309          
1310          void temp_dis(bit on_off) 
1311          {
1312   1        if(on_off) {lcd_03h=lcd_03h|B0100_0000;       }
1313   1        else           {lcd_03h=lcd_03h&B1011_1111;   }
1314   1      
1315   1        TM1722_STB=1;            //端口配置初始化
1316   1        TM1722_CLK=1;
1317   1        TM1722_DIO=1;
1318   1        TM1722_Write_Byte(0x00); //工作模式
1319   1        TM1722_STB=1;
1320   1        TM1722_Write_Byte(0x44);   //固定地址模式
1321   1        TM1722_STB=1;
1322   1      
1323   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1324   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1325   1        TM1722_STB=1;
1326   1      
1327   1      
1328   1        TM1722_Write_Byte(0x93); 
1329   1        TM1722_STB=1;
1330   1      }
1331          
1332          
1333          
1334          void hot_dis(bit on_off) 
1335          {
1336   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_1000;       }
1337   1        else           {lcd_0eh=lcd_0eh&B1111_0111;   }
1338   1      
1339   1        TM1722_STB=1;            //端口配置初始化
1340   1        TM1722_CLK=1;
1341   1        TM1722_DIO=1;
1342   1        TM1722_Write_Byte(0x00); //工作模式
1343   1        TM1722_STB=1;
1344   1        TM1722_Write_Byte(0x44);   //固定地址模式
1345   1        TM1722_STB=1;
1346   1      
1347   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1348   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1349   1        TM1722_STB=1;
1350   1      
1351   1      
1352   1        TM1722_Write_Byte(0x93); 
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 23  

1353   1        TM1722_STB=1;
1354   1      }
1355          
1356          
1357          
1358          void hot1_dis(bit on_off) 
1359          {
1360   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0100;       }
1361   1        else           {lcd_0eh=lcd_0eh&B1111_1011;   }
1362   1      
1363   1        TM1722_STB=1;            //端口配置初始化
1364   1        TM1722_CLK=1;
1365   1        TM1722_DIO=1;
1366   1        TM1722_Write_Byte(0x00); //工作模式
1367   1        TM1722_STB=1;
1368   1        TM1722_Write_Byte(0x44);   //固定地址模式
1369   1        TM1722_STB=1;
1370   1      
1371   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1372   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1373   1        TM1722_STB=1;
1374   1      
1375   1      
1376   1        TM1722_Write_Byte(0x93); 
1377   1        TM1722_STB=1;
1378   1      }
1379          
1380          
1381          
1382          
1383          
1384          void hot2_dis(bit on_off) 
1385          {
1386   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0010;       }
1387   1        else           {lcd_0eh=lcd_0eh&B1111_1101;   }
1388   1      
1389   1        TM1722_STB=1;            //端口配置初始化
1390   1        TM1722_CLK=1;
1391   1        TM1722_DIO=1;
1392   1        TM1722_Write_Byte(0x00); //工作模式
1393   1        TM1722_STB=1;
1394   1        TM1722_Write_Byte(0x44);   //固定地址模式
1395   1        TM1722_STB=1;
1396   1      
1397   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1398   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1399   1        TM1722_STB=1;
1400   1      
1401   1      
1402   1        TM1722_Write_Byte(0x93); 
1403   1        TM1722_STB=1;
1404   1      }
1405             
1406          
1407          
1408          
1409          void hot3_dis(bit on_off) 
1410          {
1411   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0001;       }
1412   1        else           {lcd_0eh=lcd_0eh&B1111_1110;   }
1413   1      
1414   1        TM1722_STB=1;            //端口配置初始化
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 24  

1415   1        TM1722_CLK=1;
1416   1        TM1722_DIO=1;
1417   1        TM1722_Write_Byte(0x00); //工作模式
1418   1        TM1722_STB=1;
1419   1        TM1722_Write_Byte(0x44);   //固定地址模式
1420   1        TM1722_STB=1;
1421   1      
1422   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1423   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1424   1        TM1722_STB=1;
1425   1      
1426   1      
1427   1        TM1722_Write_Byte(0x93); 
1428   1        TM1722_STB=1;
1429   1      }
1430          
1431          
1432          
1433          
1434          
1435          void H1_dis(bit on_off) 
1436          {
1437   1        if(on_off) {lcd_0bh=lcd_0bh|B0100_0000;       }
1438   1        else           {lcd_0bh=lcd_0bh&B1011_1111;   }
1439   1      
1440   1        TM1722_STB=1;            //端口配置初始化
1441   1        TM1722_CLK=1;
1442   1        TM1722_DIO=1;
1443   1        TM1722_Write_Byte(0x00); //工作模式
1444   1        TM1722_STB=1;
1445   1        TM1722_Write_Byte(0x44);   //固定地址模式
1446   1        TM1722_STB=1;
1447   1      
1448   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1449   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1450   1        TM1722_STB=1;
1451   1      
1452   1      
1453   1        TM1722_Write_Byte(0x93); 
1454   1        TM1722_STB=1;
1455   1      }
1456          
1457          
1458          void H2_dis(bit on_off) 
1459          {
1460   1        if(on_off) {lcd_0bh=lcd_0bh|B0010_0000;       }
1461   1        else           {lcd_0bh=lcd_0bh&B1101_1111;   }
1462   1      
1463   1        TM1722_STB=1;            
1464   1        TM1722_CLK=1;
1465   1        TM1722_DIO=1;
1466   1        TM1722_Write_Byte(0x00); //工作模式
1467   1        TM1722_STB=1;
1468   1        TM1722_Write_Byte(0x44);   //固定地址模式
1469   1        TM1722_STB=1;
1470   1      
1471   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1472   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1473   1        TM1722_STB=1;
1474   1      
1475   1      
1476   1        TM1722_Write_Byte(0x93); 
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 25  

1477   1        TM1722_STB=1;
1478   1      }
1479          
1480          
1481          
1482          
1483          
1484          void H3_dis(bit on_off) 
1485          {
1486   1        if(on_off) {lcd_0bh=lcd_0bh|B0001_0000;       }
1487   1        else           {lcd_0bh=lcd_0bh&B1110_1111;   }
1488   1      
1489   1        TM1722_STB=1;            //端口配置初始化
1490   1        TM1722_CLK=1;
1491   1        TM1722_DIO=1;
1492   1        TM1722_Write_Byte(0x00); //工作模式
1493   1        TM1722_STB=1;
1494   1        TM1722_Write_Byte(0x44);   //固定地址模式
1495   1        TM1722_STB=1;
1496   1      
1497   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1498   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1499   1        TM1722_STB=1;
1500   1      
1501   1      
1502   1        TM1722_Write_Byte(0x93); 
1503   1        TM1722_STB=1;
1504   1      }
1505          
1506          
1507          
1508          void tb_dis(bit on_off) 
1509          {
1510   1        if(on_off) {lcd_03h=lcd_03h|B0001_0000;       }
1511   1        else           {lcd_03h=lcd_03h&B1110_1111;   }
1512   1      
1513   1        TM1722_STB=1;            //端口配置初始化
1514   1        TM1722_CLK=1;
1515   1        TM1722_DIO=1;
1516   1        TM1722_Write_Byte(0x00); //工作模式
1517   1        TM1722_STB=1;
1518   1        TM1722_Write_Byte(0x44);   //固定地址模式
1519   1        TM1722_STB=1;
1520   1      
1521   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1522   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1523   1        TM1722_STB=1;
1524   1      
1525   1      
1526   1        TM1722_Write_Byte(0x93); 
1527   1        TM1722_STB=1;
1528   1      }
1529          
1530          
1531          
1532          
1533          
1534          
1535          
1536          void jg_dis(bit on_off) 
1537          {
1538   1        if(on_off) {lcd_03h=lcd_03h|B0010_0000;       }
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 26  

1539   1        else           {lcd_03h=lcd_03h&B1101_1111;   }
1540   1      
1541   1        TM1722_STB=1;            //端口配置初始化
1542   1        TM1722_CLK=1;
1543   1        TM1722_DIO=1;
1544   1        TM1722_Write_Byte(0x00); //工作模式
1545   1        TM1722_STB=1;
1546   1        TM1722_Write_Byte(0x44);   //固定地址模式
1547   1        TM1722_STB=1;
1548   1      
1549   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1550   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1551   1        TM1722_STB=1;
1552   1      
1553   1      
1554   1        TM1722_Write_Byte(0x93); 
1555   1        TM1722_STB=1;
1556   1      }
1557          
1558          
1559          
1560          
1561          
1562          
1563          void mode_dis(bit on_off) 
1564          {
1565   1        if(on_off) {lcd_03h=lcd_03h|B1000_0000;       }
1566   1        else           {lcd_03h=lcd_03h&B0111_1111;   }
1567   1      
1568   1        TM1722_STB=1;            //端口配置初始化
1569   1        TM1722_CLK=1;
1570   1        TM1722_DIO=1;
1571   1        TM1722_Write_Byte(0x00); //工作模式
1572   1        TM1722_STB=1;
1573   1        TM1722_Write_Byte(0x44);   //固定地址模式
1574   1        TM1722_STB=1;
1575   1      
1576   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1577   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1578   1        TM1722_STB=1;
1579   1      
1580   1      
1581   1        TM1722_Write_Byte(0x93); 
1582   1        TM1722_STB=1;
1583   1      }
1584          
1585          
1586          
1587          
1588          
1589          
1590          
1591          
1592          void bf_dis(bit on_off) 
1593          {
1594   1        if(on_off) {lcd_06h=lcd_06h|B0000_1000;       }
1595   1        else           {lcd_06h=lcd_06h&B1111_0111;   }
1596   1      
1597   1        TM1722_STB=1;            //端口配置初始化
1598   1        TM1722_CLK=1;
1599   1        TM1722_DIO=1;
1600   1        TM1722_Write_Byte(0x00); //工作模式
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 27  

1601   1        TM1722_STB=1;
1602   1        TM1722_Write_Byte(0x44);   //固定地址模式
1603   1        TM1722_STB=1;
1604   1      
1605   1        TM1722_Write_Byte(0xc6);         //显示寄存器的00H单元开始
1606   1        TM1722_Write_Byte(lcd_06h);     //给显示寄存器送数据，
1607   1        TM1722_STB=1;
1608   1      
1609   1      
1610   1        TM1722_Write_Byte(0x93); 
1611   1        TM1722_STB=1;
1612   1      }
1613          
1614          
1615          
1616          
1617          
1618          void set_dis(bit on_off) 
1619          {
1620   1        if(on_off) {lcd_03h=lcd_03h|B0000_0100;       }
1621   1        else           {lcd_03h=lcd_03h&B1111_1011;   }
1622   1      
1623   1        TM1722_STB=1;            //端口配置初始化
1624   1        TM1722_CLK=1;
1625   1        TM1722_DIO=1;
1626   1        TM1722_Write_Byte(0x00); //工作模式
1627   1        TM1722_STB=1;
1628   1        TM1722_Write_Byte(0x44);   //固定地址模式
1629   1        TM1722_STB=1;
1630   1      
1631   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1632   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1633   1        TM1722_STB=1;
1634   1      
1635   1      
1636   1        TM1722_Write_Byte(0x93); 
1637   1        TM1722_STB=1;
1638   1      }
1639          
1640          
1641          
1642          void cur_dis(bit on_off) 
1643          {
1644   1        if(on_off) {lcd_03h=lcd_03h|B0000_1000;       }
1645   1        else           {lcd_03h=lcd_03h&B1111_0111;   }
1646   1      
1647   1        TM1722_STB=1;            //端口配置初始化
1648   1        TM1722_CLK=1;
1649   1        TM1722_DIO=1;
1650   1        TM1722_Write_Byte(0x00); //工作模式
1651   1        TM1722_STB=1;
1652   1        TM1722_Write_Byte(0x44);   //固定地址模式
1653   1        TM1722_STB=1;
1654   1      
1655   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1656   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1657   1        TM1722_STB=1;
1658   1      
1659   1      
1660   1        TM1722_Write_Byte(0x93);
1661   1        TM1722_STB=1;
1662   1      }
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 28  

1663          
1664          
1665          
1666          
1667          void f_dis(bit on_off) 
1668          {
1669   1        if(on_off) {lcd_0eh=lcd_0eh|B1000_0000;       }
1670   1        else           {lcd_0eh=lcd_0eh&B0111_1111;   }
1671   1      
1672   1        TM1722_STB=1;            //端口配置初始化
1673   1        TM1722_CLK=1;
1674   1        TM1722_DIO=1;
1675   1        TM1722_Write_Byte(0x00); //工作模式
1676   1        TM1722_STB=1;
1677   1        TM1722_Write_Byte(0x44);   //固定地址模式
1678   1        TM1722_STB=1;
1679   1      
1680   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1681   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1682   1        TM1722_STB=1;
1683   1      
1684   1      
1685   1        TM1722_Write_Byte(0x93); 
1686   1        TM1722_STB=1;
1687   1      }
1688          
1689          
1690          
1691          
1692          
1693          void m_dis(bit on_off) 
1694          {
1695   1        if(on_off) {lcd_0eh=lcd_0eh|B0100_0000;       }
1696   1        else           {lcd_0eh=lcd_0eh&B1011_1111;   }
1697   1      
1698   1        TM1722_STB=1;            //端口配置初始化
1699   1        TM1722_CLK=1;
1700   1        TM1722_DIO=1;
1701   1        TM1722_Write_Byte(0x00); //工作模式
1702   1        TM1722_STB=1;
1703   1        TM1722_Write_Byte(0x44);   //固定地址模式
1704   1        TM1722_STB=1;
1705   1      
1706   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1707   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1708   1        TM1722_STB=1;
1709   1      
1710   1      
1711   1        TM1722_Write_Byte(0x93); 
1712   1        TM1722_STB=1;
1713   1      }
1714          
1715          
1716          
1717          
1718          void r_dis(bit on_off) 
1719          {
1720   1        if(on_off) {lcd_0eh=lcd_0eh|B0010_0000;       }
1721   1        else           {lcd_0eh=lcd_0eh&B1101_1111;   }
1722   1      
1723   1        TM1722_STB=1;           
1724   1        TM1722_CLK=1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 29  

1725   1        TM1722_DIO=1;
1726   1        TM1722_Write_Byte(0x00); 
1727   1        TM1722_STB=1;
1728   1        TM1722_Write_Byte(0x44);   
1729   1        TM1722_STB=1;
1730   1      
1731   1        TM1722_Write_Byte(0xce);         
1732   1        TM1722_Write_Byte(lcd_0eh);     
1733   1        TM1722_STB=1;
1734   1      
1735   1      
1736   1        TM1722_Write_Byte(0x93); 
1737   1        TM1722_STB=1;
1738   1      }
1739          
1740          
1741          
1742          
1743          void p1_dis(bit on_off) 
1744          {
1745   1        if(on_off) {lcd_0ah=lcd_0ah|B0000_1000;       }
1746   1        else           {lcd_0ah=lcd_0ah&B1111_0111;   }
1747   1      
1748   1        TM1722_STB=1;            
1749   1        TM1722_CLK=1;
1750   1        TM1722_DIO=1;
1751   1        TM1722_Write_Byte(0x00); 
1752   1        TM1722_STB=1;
1753   1        TM1722_Write_Byte(0x44);  
1754   1        TM1722_STB=1;
1755   1      
1756   1        TM1722_Write_Byte(0xca);         
1757   1        TM1722_Write_Byte(lcd_0ah);     
1758   1        TM1722_STB=1;
1759   1      
1760   1      
1761   1        TM1722_Write_Byte(0x93); 
1762   1        TM1722_STB=1;
1763   1      }
1764          
1765          
1766          
1767          
1768          void p2_dis(bit on_off) 
1769          {
1770   1        if(on_off) {lcd_07h=lcd_07h|B0000_1000;       }
1771   1        else           {lcd_07h=lcd_07h&B1111_0111;   }
1772   1      
1773   1        TM1722_STB=1;            
1774   1        TM1722_CLK=1;
1775   1        TM1722_DIO=1;
1776   1        TM1722_Write_Byte(0x00); 
1777   1        TM1722_STB=1;
1778   1        TM1722_Write_Byte(0x44);   
1779   1        TM1722_STB=1;
1780   1      
1781   1        TM1722_Write_Byte(0xc7);         
1782   1        TM1722_Write_Byte(lcd_07h);     
1783   1        TM1722_STB=1;
1784   1      
1785   1      
1786   1        TM1722_Write_Byte(0x93); 
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 30  

1787   1        TM1722_STB=1;
1788   1      }
1789          
1790          
1791          
1792          
1793          void s13_dis(bit on_off) 
1794          {
1795   1        if(on_off) {lcd_0eh=lcd_0eh|B0001_0000;       }
1796   1        else           {lcd_0eh=lcd_0eh&B1110_1111;   }
1797   1      
1798   1        TM1722_STB=1;          
1799   1        TM1722_CLK=1;
1800   1        TM1722_DIO=1;
1801   1        TM1722_Write_Byte(0x00); 
1802   1        TM1722_STB=1;
1803   1        TM1722_Write_Byte(0x44);   
1804   1        TM1722_STB=1;
1805   1      
1806   1        TM1722_Write_Byte(0xce);         
1807   1        TM1722_Write_Byte(lcd_0eh);     
1808   1        TM1722_STB=1;
1809   1      
1810   1      
1811   1        TM1722_Write_Byte(0x93); 
1812   1        TM1722_STB=1;
1813   1      }
1814          
1815          
1816          
1817          
1818          void s14_dis(bit on_off) 
1819          {
1820   1        if(on_off) {lcd_0fh=lcd_0fh|B0001_0000;       }
1821   1        else           {lcd_0fh=lcd_0fh&B1110_1111;   }
1822   1      
1823   1        TM1722_STB=1;            
1824   1        TM1722_CLK=1;
1825   1        TM1722_DIO=1;
1826   1        TM1722_Write_Byte(0x00); 
1827   1        TM1722_STB=1;
1828   1        TM1722_Write_Byte(0x44);   
1829   1        TM1722_STB=1;
1830   1      
1831   1        TM1722_Write_Byte(0xcf);         
1832   1        TM1722_Write_Byte(lcd_0fh);     
1833   1        TM1722_STB=1;
1834   1      
1835   1      
1836   1        TM1722_Write_Byte(0x93); 
1837   1        TM1722_STB=1;
1838   1      }
1839          
1840          
1841          void s15_dis(bit on_off) 
1842          {
1843   1        if(on_off) {lcd_0fh=lcd_0fh|B0010_0000;       }
1844   1        else           {lcd_0fh=lcd_0fh&B1101_1111;   }
1845   1      
1846   1        TM1722_STB=1;            
1847   1        TM1722_CLK=1;
1848   1        TM1722_DIO=1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 31  

1849   1        TM1722_Write_Byte(0x00); 
1850   1        TM1722_STB=1;
1851   1        TM1722_Write_Byte(0x44);   
1852   1        TM1722_STB=1;
1853   1      
1854   1        TM1722_Write_Byte(0xcf);         
1855   1        TM1722_Write_Byte(lcd_0fh);     
1856   1        TM1722_STB=1;
1857   1      
1858   1      
1859   1        TM1722_Write_Byte(0x93); 
1860   1        TM1722_STB=1;
1861   1      }
1862          
1863          
1864          
1865          
1866          
1867          
1868          void hot_select(uchar dd)
1869          {
1870   1       switch(dd)
1871   1        {
1872   2         case 1: {hot1_dis(1); hot2_dis(0); hot3_dis(0); H1_dis(1);  H2_dis(0); H3_dis(0); }break;    
1873   2         case 2: {hot1_dis(1); hot2_dis(1); hot3_dis(0); H1_dis(1);  H2_dis(1); H3_dis(0); }break;    
1874   2         case 3: {hot1_dis(1); hot2_dis(1); hot3_dis(1); H1_dis(1);  H2_dis(1); H3_dis(1); }break;    
1875   2         case 4: {hot1_dis(1); hot2_dis(0); hot3_dis(1); H1_dis(1);  H2_dis(0); H3_dis(1); }break;    
1876   2         case 5: {hot1_dis(0); hot2_dis(1); hot3_dis(1); H1_dis(0);  H2_dis(1); H3_dis(1); }break;    
1877   2         case 6: {hot1_dis(0); hot2_dis(1); hot3_dis(0); H1_dis(0);  H2_dis(1); H3_dis(0); }break;    
1878   2         case 7: {hot1_dis(0); hot2_dis(0); hot3_dis(1); H1_dis(0);  H2_dis(0); H3_dis(1); }break;
1879   2        }
1880   1      
1881   1      
1882   1      }
1883          
1884          
1885          
1886          
1887          
1888          
1889          void  mode_chose(void)
1890          {
1891   1       read_data();
1892   1      
1893   1       lcd_clear(0x00);  
1894   1      
1895   1      
1896   1       dis1(1,mode_num); mode_dis(1);  Delay1ms(1000);  mode_dis(0);
1897   1       
1898   1       
1899   1       temp_dis(1);
1900   1       cur_dis(1);
1901   1      
1902   1       fan_dis(fan_num);
1903   1      
1904   1      
1905   1       //hot_select(fenduan_num);
1906   1      
1907   1       //if(tb_num==1)  tb_dis(1);  else  tb_dis(0); 
1908   1      
1909   1       s13_dis(1);
1910   1       s14_dis(1);
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 32  

1911   1       s15_dis(1);
1912   1      }
1913          
1914          
1915          
1916          
1917          //***********************************************************************
1918          void  pwm_set(uint pwmdata)
1919          {
1920   1       
1921   1       P_SW2 |= 0x80;      
1922   1       PWM5T2 = pwmdata; 
1923   1                                                     
1924   1       P_SW2 &= ~0x80;
1925   1      
1926   1      }
1927          
1928          
1929          
1930          
1931          void fan_run(void)
1932          {
1933   1       P_SW2 |= 0x80;    
1934   1       PWMCR =0x88;      
1935   1       P_SW2 &= ~0x80;
1936   1      
1937   1      }
1938          
1939          
1940          
1941          
1942          
1943          void fan_stop(void)
1944          {
1945   1       pwm_set(10);
1946   1       P_SW2 |= 0x80;    
1947   1       PWMCR =0x00;     
1948   1       P_SW2 &= ~0x80;
1949   1       pwm5=10;
1950   1      
1951   1      }
1952          
1953          
1954          
1955          
1956          
1957          void fan_run_stop(uchar dd)      
1958          {
1959   1       switch(dd)
1960   1        {
1961   2         case 0: { fan_stop();  fan_bit=0; }break;
1962   2      
1963   2         case 1: { fan_run(); pwm5=4000; pwm_set(pwm5); fan_bit=1; fan_rs_bit=1;}break;
1964   2      
1965   2         case 2: { fan_run(); pwm5=4500; pwm_set(pwm5); fan_bit=1; fan_rs_bit=1;}break;
1966   2      
1967   2         case 3: { fan_run(); pwm5=5000; pwm_set(pwm5); fan_bit=1; fan_rs_bit=1;}break;
1968   2      
1969   2         case 4: { fan_run(); pwm5=5500; pwm_set(pwm5); fan_bit=1; fan_rs_bit=1;}break;
1970   2      
1971   2         case 5: { fan_run(); pwm5=6000; pwm_set(pwm5); fan_bit=1; fan_rs_bit=1;}break;
1972   2      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 33  

1973   2         case 6: { fan_run(); pwm5=6500; pwm_set(pwm5); fan_bit=1; fan_rs_bit=1;}break;
1974   2      
1975   2        }
1976   1      
1977   1      }
1978          
1979          //***********************************************************************
1980          
1981           
1982          
1983          
1984          
1985          
1986          
1987          
1988          void Uart() interrupt 4 
1989          {
1990   1       if (RI) {
1991   2                        RI=0;                         
1992   2          if (g_need_process_datas) return;             
1993   2                      if (g_recv_buffer_index >= 64) g_recv_buffer_index = 0;  
1994   2                      g_recv_buffer[g_recv_buffer_index++] = SBUF;   
1995   2                      g_current_need_times = g_need_times;                            
1996   2              }
1997   1       
1998   1      }
1999          
2000          //***********************************************************************
2001          int PID1(int Set_value, int Real_value) 
2002          {
2003   1      int error;
2004   1      float P_term, D_term;
2005   1      int pid_out;
2006   1      
2007   1      
2008   1      error=Set_value - Real_value;
2009   1      
2010   1      P_term =Kp*error; 
2011   1      
2012   1      I_term1+=Ki*error ;
2013   1      
2014   1      if(I_term1>PID_MAX) I_term1=PID_MAX; 
2015   1      
2016   1      else if(I_term1<0) I_term1=0; 
2017   1      
2018   1      D_term =Kd*(error - last_error1) ;
2019   1      
2020   1      last_error1=error; 
2021   1      
2022   1      pid_out=(signed int) (P_term+I_term1+D_term); 
2023   1      
2024   1      if(pid_out>PID_MAX) pid_out=PID_MAX; 
2025   1      
2026   1      else if(pid_out<PID_MIN) pid_out=PID_MIN;
2027   1      
2028   1      return(pid_out);
2029   1      }
2030          
2031          //***********************************************************************
2032          int PID2(int Set_value, int Real_value) 
2033          {
2034   1      int error;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 34  

2035   1      float P_term, D_term;
2036   1      int pid_out;
2037   1      
2038   1      
2039   1      error=Set_value - Real_value;
2040   1      
2041   1      P_term =Kp*error; 
2042   1      
2043   1      I_term2+=Ki*error ;
2044   1      
2045   1      if(I_term2>PID_MAX) I_term2=PID_MAX; 
2046   1      
2047   1      else if(I_term2<0) I_term2=0; 
2048   1      
2049   1      D_term =Kd*(error - last_error2) ;
2050   1      
2051   1      last_error2=error; 
2052   1      
2053   1      pid_out=(signed int) (P_term+I_term2+D_term); 
2054   1      
2055   1      if(pid_out>PID_MAX) pid_out=PID_MAX; 
2056   1      
2057   1      else if(pid_out<PID_MIN) pid_out=PID_MIN;
2058   1      
2059   1      return(pid_out);
2060   1      }
2061          
2062          //***********************************************************************
2063          int PID3(int Set_value, int Real_value) 
2064          {
2065   1      int error;
2066   1      float P_term, D_term;
2067   1      int pid_out;
2068   1      
2069   1      
2070   1      error=Set_value - Real_value;
2071   1      
2072   1      P_term =Kp*error; 
2073   1      
2074   1      I_term3+=Ki*error ;
2075   1      
2076   1      if(I_term3>PID_MAX) I_term3=PID_MAX; 
2077   1      
2078   1      else if(I_term3<0) I_term3=0; 
2079   1      
2080   1      D_term =Kd*(error - last_error3) ;
2081   1      
2082   1      last_error3=error; 
2083   1      
2084   1      pid_out=(signed int) (P_term+I_term3+D_term); 
2085   1      
2086   1      if(pid_out>PID_MAX) pid_out=PID_MAX; 
2087   1      
2088   1      else if(pid_out<PID_MIN) pid_out=PID_MIN;
2089   1      
2090   1      return(pid_out);
2091   1      }
2092          
2093          
2094          
2095          
2096          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 35  

2097          //***********************************************************************
2098          int PID4(int Set_value, int Real_value) 
2099          {
2100   1      int error;
2101   1      float P_term, D_term;
2102   1      int pid_out;
2103   1      
2104   1      
2105   1      error=Set_value - Real_value;
2106   1      
2107   1      P_term =Kp*error; 
2108   1      
2109   1      I_term4+=Ki*error ;
2110   1      
2111   1      if(I_term4>PID_MAX) I_term4=PID_MAX; 
2112   1      
2113   1      else if(I_term4<0) I_term4=0; 
2114   1      
2115   1      D_term =Kd*(error - last_error4) ;
2116   1      
2117   1      last_error4=error; 
2118   1      
2119   1      pid_out=(signed int) (P_term+I_term4+D_term); 
2120   1      
2121   1      if(pid_out>PID_MAX) pid_out=PID_MAX; 
2122   1      
2123   1      else if(pid_out<PID_MIN) pid_out=PID_MIN;
2124   1      
2125   1      return(pid_out);
2126   1      }
2127          
2128           /*
2129          
2130          //***********************************************************************
2131          int PID5(int Set_value, int Real_value) //标准PID温度控制算法
2132          {
2133          int error;
2134          float P_term, D_term;
2135          int pid_out;
2136          
2137          
2138          error=Set_value - Real_value;//误差量
2139          
2140          P_term =Kp*error; //比例量
2141          
2142          I_term5+=Ki*error ;//积分量
2143          
2144          if(I_term5>PID_MAX) I_term5=PID_MAX; //限定积分量 上限
2145          
2146          else if(I_term5<0) I_term5=0; //限定积分量下限
2147          
2148          D_term =Kd*(error - last_error5) ;//微分量
2149          
2150          last_error5=error; //缓存当 前误差量
2151          
2152          pid_out=(signed int) (P_term+I_term5+D_term); //PID 控制量计算
2153          
2154          if(pid_out>PID_MAX) pid_out=PID_MAX; //控制量上限=PID_ MAX
2155          
2156          else if(pid_out<PID_MIN) pid_out=PID_MIN;//控制量下限=100
2157          
2158          return(pid_out);
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 36  

2159          }
2160          
2161          
2162          //***********************************************************************
2163          int PID6(int Set_value, int Real_value) //标准PID温度控制算法
2164          {
2165          int error;
2166          float P_term, D_term;
2167          int pid_out;
2168          
2169          
2170          error=Set_value - Real_value;//误差量
2171          
2172          P_term =Kp*error; //比例量
2173          
2174          I_term6+=Ki*error ;//积分量
2175          
2176          if(I_term6>PID_MAX) I_term6=PID_MAX; //限定积分量 上限
2177          
2178          else if(I_term6<0) I_term6=0; //限定积分量下限
2179          
2180          D_term =Kd*(error - last_error6) ;//微分量
2181          
2182          last_error6=error; //缓存当 前误差量
2183          
2184          pid_out=(signed int) (P_term+I_term6+D_term); //PID 控制量计算
2185          
2186          if(pid_out>PID_MAX) pid_out=PID_MAX; //控制量上限=PID_ MAX
2187          
2188          else if(pid_out<PID_MIN) pid_out=PID_MIN;//控制量下限=100
2189          
2190          return(pid_out);
2191          }        */
2192          
2193          //***********************************************************************
2194          
2195          
2196          
2197          
2198          void tm0_isr() interrupt 1  using 1             
2199          {
2200   1       recv_cnt++;
2201   1       if(recv_cnt>4)
2202   1        {
2203   2         recv_cnt=0;
2204   2          if (g_recv_buffer_index > 0 && g_need_process_datas == 0) {
2205   3              if (g_current_need_times-- == 0) {     
2206   4                              g_need_process_datas = 1;                       
2207   4                         }            
2208   3           }
2209   2         }
2210   1      
2211   1      
2212   1      
2213   1      
2214   1      
2215   1      //-------------------------------------------------------------------------------------------
2216   1       if(tm1_on_bit)
2217   1        {
2218   2         tmp_cnt1++;
2219   2      
2220   2         if(tmp_cnt1==1)                           {if(temp1<temp_set1){led6=0; out1=0;}  tm1_bit=0;}
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 37  

2221   2      
2222   2         if((tm1_bit==0)&&(tmp_cnt1>=tm1_pwm))     {led6=1; out1=1; tm1_bit=1;}
2223   2      
2224   2         else if((tm1_bit==1)&&(tmp_cnt1>=1000))       {tm1_bit=0; tmp_cnt1=0;}
2225   2        }
2226   1      
2227   1       //--------------------------------------------------------------------------------------------
2228   1       if(tm2_on_bit)
2229   1        {
2230   2         tmp_cnt2++;
2231   2      
2232   2         if(tmp_cnt2==1)                           {if(temp2<temp_set2){led4=0; out2=0;}  tm2_bit=0;}
2233   2      
2234   2         if((tm2_bit==0)&&(tmp_cnt2>=tm2_pwm))     {led4=1; out2=1; tm2_bit=1;}
2235   2      
2236   2         else if((tm2_bit==1)&&(tmp_cnt2>=1000))       {tm2_bit=0; tmp_cnt2=0;}
2237   2        }
2238   1      
2239   1       //----------------------------------------------------------------------------------------------
2240   1       if(tm3_on_bit)
2241   1        {
2242   2         tmp_cnt3++;
2243   2      
2244   2         if(tmp_cnt3==1)                           {if(temp3<temp_set3){led2=0;  out3=0;}  tm3_bit=0;}
2245   2      
2246   2         if((tm3_bit==0)&&(tmp_cnt3>=tm3_pwm))     {led2=1; out3=1; tm3_bit=1;}
2247   2      
2248   2         else if((tm3_bit==1)&&(tmp_cnt3>=1000))       {tm3_bit=0; tmp_cnt3=0;}
2249   2        }
2250   1      
2251   1        if(sp_bit==0)
2252   1        {
2253   2         cnt3++;
2254   2         if(cnt3>100) {cnt3=0; speak=sp_bit=1;}
2255   2        
2256   2        }
2257   1       
2258   1      }
2259          
2260          
2261          
2262          
2263          
2264          
2265          
2266          
2267          
2268          
2269          //******************************************************************************************
2270          
2271          
2272          
2273          
2274          
2275          
2276          
2277          void t3int() interrupt 19  using 2        //50ms  定时器3  11.0592
2278          {
2279   1      
2280   1       key_buf=P0&0x0f; 
2281   1      
2282   1       
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 38  

2283   1      
2284   1      
2285   1       if(fan_close_bit) 
2286   1         {
2287   2              cnt4++;
2288   2              if(cnt4>1200) 
2289   2                {
2290   3                  cnt4=0; 
2291   3                      cnt5++;   
2292   3                      if(cnt5>=fan_close_cnt)  {cnt5=0; fan_close_ok=1;}
2293   3                        
2294   3                }
2295   2              
2296   2         }
2297   1      
2298   1       dis_temp_cnt++; 
2299   1       if(dis_temp_cnt>10) {dis_temp_cnt=0; dis_temp_bit=1;}
2300   1      
2301   1      
2302   1       if(fan_bit)  
2303   1         {
2304   2              fan_cnt++;
2305   2              if(fan_cnt>2)  { fan_cnt=0; fan_bit2=1; fan_bit3=~fan_bit3; }
2306   2         }
2307   1      
2308   1       /*
2309   1       if(sp_bit==0)
2310   1        {
2311   1         cnt3++;
2312   1         if(cnt3>2) {cnt3=0; speak=sp_bit=1;}
2313   1        
2314   1        }  */
2315   1      
2316   1      
2317   1      
2318   1      
2319   1      
2320   1      if(power_bit==0) 
2321   1        {
2322   2         
2323   2         if(power_cnt>9) { led5=~led5; power_cnt=0; }
2324   2         else power_cnt++;
2325   2      
2326   2        }
2327   1      
2328   1      
2329   1      
2330   1      
2331   1      
2332   1      if(temp_set_bit)  
2333   1       {
2334   2        save_cnt++;
2335   2        if(save_cnt>80) {save_cnt=0;  save_bit=1; } 
2336   2      
2337   2      
2338   2        if(temp_set_cnt>9) {temp_set_cnt=0;   ss_bit=~ss_bit;}
2339   2        else temp_set_cnt++;
2340   2      
2341   2       }
2342   1      
2343   1      else {
2344   2                ss_cnt++;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 39  

2345   2                if(ss_cnt>40) { ss_cnt=0; hot_HT_bit=1;}
2346   2      
2347   2      
2348   2            }
2349   1      
2350   1      
2351   1      
2352   1      }
2353          
2354          
2355          
2356          //******************************************************************************************************
2357          
2358          void main(void)
2359          { 
2360   1      
2361   1         hot_ok=0;
2362   1         hot_fan=0;
2363   1         lcd_bl=1;
2364   1         power_bit=1;
2365   1      
2366   1          P0M0 =B0110_0000;  
2367   1          P0M1 = 0x00;
2368   1              
2369   1                       
2370   1      
2371   1          
2372   1              P1M0 = 0x00;
2373   1          P1M1 = 0x00;
2374   1      
2375   1      
2376   1          P2M0 = B0000_1000; 
2377   1          P2M1 = 0x00;
2378   1      
2379   1      
2380   1          P3M0 = 0x00;   
2381   1          P3M1 = 0x00;
2382   1      
2383   1          P4M0 = 0x00;  
2384   1          P4M1 = 0x00;
2385   1      
2386   1          P5M0 = 0x00;
2387   1          P5M1 = 0x00;
2388   1      
2389   1              
2390   1      //***************************************************************************
2391   1              P_SW2 |= 0x80;                  
2392   1          PWMCFG = 0x08;                  
2393   1              //PWMCR  = 0x04;                                
2394   1          PWMCKS = 0x00;                  
2395   1          PWMC = CYCLE;                   
2396   1                        
2397   1       //----------------------------------------------------------------------------------
2398   1          PWM5T1 = 0;                  
2399   1          PWM5T2 = 10;                
2400   1                                         
2401   1          PWM5CR = 0x00;                  
2402   1       //----------------------------------------------------------------------------------
2403   1      
2404   1      
2405   1              PWMFDCR=0x30;                   
2406   1          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 40  

2407   1          //PWMCR |= 0x80;                  
2408   1      
2409   1          P_SW2 &= ~0x80;
2410   1      
2411   1      
2412   1      //**********************************************************************************
2413   1        /*     
2414   1        ACC = P_SW1;                            //串口1切换
2415   1        ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
2416   1        ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
2417   1        P_SW1 = ACC; 
2418   1                      
2419   1                */
2420   1                                                                //串口2切换
2421   1       
2422   1      
2423   1                                                                //PWM口切换
2424   1              //P_SW2 &=~PWM2345_S;     //PWM_2345_S=0 P3.7/PWM2 P2.1/PWM3 P2.2/PWM4 P2.3/PWM5 P2.4/PWMFLT
2425   1              //P_SW2 |= PWM2345_S;             //PWM_2345_S=1 P2.7/PWM2 P4.5/PWM3 P4.4/PWM4 P4.2/PWM5 P0.5/PWMFLT
2426   1      
2427   1      
2428   1       
2429   1        
2430   1       UartInit();
2431   1      
2432   1       InitADC();
2433   1      
2434   1       Timer0Init();
2435   1      
2436   1       Timer3Init();
2437   1         
2438   1       //ES=1;
2439   1       
2440   1      
2441   1       EA=1;
2442   1      
2443   1       read_mode();   
2444   1       read_data();
2445   1       fan_close_read();
2446   1      
2447   1       hot_power_read();
2448   1       fan_power_read();
2449   1      
2450   1       lcd_clear(0x00);
2451   1      
2452   1       hot_in=1;
2453   1      
2454   1               
2455   1      
2456   1       if(key_buf==fn_key)  
2457   1        {
2458   2         speak=sp_bit=0;
2459   2         lcd_bl=0;
2460   2         led2=led1=led3=0;
2461   2         dis1(1,fan_close_cnt);
2462   2      
2463   2         while(key_buf==fn_key) WDT_CONTR=0X34;
2464   2      
2465   2         while(1)
2466   2           {
2467   3                Delay1ms(50);
2468   3      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 41  

2469   3                if(key_buf==up_key)      {speak=sp_bit=0; fan_close_cnt++; if(fan_close_cnt>250) fan_close_cnt=250; dis
             -1(1,fan_close_cnt);   Delay1ms(200);;}
2470   3      
2471   3                else if(key_buf==dn_key) {speak=sp_bit=0; fan_close_cnt--; if(fan_close_cnt<10)  fan_close_cnt=10;  dis
             -1(1,fan_close_cnt);   Delay1ms(200);}
2472   3      
2473   3                else if(key_buf==fn_key) {speak=sp_bit=0; fan_close_save();  while(key_buf==fn_key) WDT_CONTR=0X34; bre
             -ak;}
2474   3               }
2475   2              led1=led2=led3=1;
2476   2              led4=led6=1;
2477   2              lcd_clear(0x00); 
2478   2              lcd_bl=1;
2479   2        }
2480   1      
2481   1      
2482   1       led5=0;
2483   1                
2484   1       //while(1)
2485   1        //{
2486   1         //Delay1ms(50);
2487   1         //if(key_buf==power_key) 
2488   1          //{
2489   1               speak=sp_bit=0; 
2490   1               led5=1;
2491   1               lcd_clear(0xff); 
2492   1               lcd_bl=0; 
2493   1               power_bit=1;  
2494   1               led6=0;        Delay1ms(200);
2495   1               led4=0;        Delay1ms(200);
2496   1               led2=0;        Delay1ms(200);
2497   1               led1=0;        Delay1ms(200);
2498   1               led3=0;        Delay1ms(200);
2499   1               led5=0;        
2500   1               Delay1ms(1000);
2501   1               lcd_clear(0x00);
2502   1               
2503   1              
2504   1              // break;
2505   1              //}
2506   1      
2507   1        //}     
2508   1      
2509   1       led1=led2=led3=1;
2510   1       led4=led5=led6=1;
2511   1       tb_bit=0;
2512   1      
2513   1       mode_chose();
2514   1                        
2515   1      
2516   1       save_bit=0;
2517   1      
2518   1       hot_HT_bit=0;
2519   1       hot_fan_bit=0;
2520   1       ss_cnt=0;
2521   1       auto_bit=0;
2522   1      
2523   1       hot_fan=1;        
2524   1       Delay1ms(200);
2525   1       hot_fan=0;
2526   1       
2527   1       s13_dis(1); s14_dis(0);
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 42  

2528   1      
2529   1       temp_set1=(int)tm_set1;
2530   1       temp_set2=(int)tm_set2;
2531   1       temp_set3=(int)tm_set3;
2532   1       temp_set4=(int)tm_set4;
2533   1       temp_set5=(int)tm_set5;
2534   1       temp_set6=(int)tm_set6;
2535   1      
2536   1       last_error1=0;
2537   1       last_error2=0;
2538   1       last_error3=0;
2539   1       last_error4=0;
2540   1       last_error5=0;
2541   1       last_error6=0;
2542   1      
2543   1       I_term1=0;
2544   1       I_term2=0;
2545   1       I_term3=0;
2546   1       I_term4=0;
2547   1       I_term5=0;
2548   1       I_term6=0;
2549   1      
2550   1       temp_num=1;    
2551   1       dis_temp_bit=1;
2552   1       hot_HT_bit=1;
2553   1       if(fan_power==0)   { fan_run_stop(fan_num);   fan_rs_bit=1;  }
2554   1      
2555   1       if(hot_power==0)       led5=0;  else  led5=1;
2556   1      
2557   1       recv_cnt=0;
2558   1       g_recv_buffer_index = 0;              
2559   1       g_current_need_times = g_need_times;  
2560   1       g_need_process_datas = 0;             
2561   1       //---------------------------------------------------------------------------------------
2562   1       while(1)
2563   1       {
2564   2         WDT_CONTR=0X34;
2565   2      
2566   2         if (g_need_process_datas) {      
2567   3                      
2568   3                      if (parse_recv_buffer(g_recv_buffer,g_recv_buffer_index)==2)    
2569   3                               {        }
2570   3                                
2571   3                      g_recv_buffer_index = 0;
2572   3                      g_need_process_datas = 0;                       
2573   3              }
2574   2      
2575   2         
2576   2         
2577   2      
2578   2              if((hot_in==0)&&(tb_bit==0))  
2579   2               {
2580   3                     tb_bit=1;
2581   3                         hot_in_data=1;         
2582   3                    }
2583   2      
2584   2                       else if((hot_in==1)&&(tb_bit==1))  
2585   2                        {        
2586   3                         tb_bit=0;
2587   3                         hot_in_data=0;
2588   3                        }            
2589   2      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 43  

2590   2      
2591   2      
2592   2                   
2593   2      
2594   2                      
2595   2      
2596   2      
2597   2      
2598   2      
2599   2         
2600   2         if(fan_bit2) { fan_bit2=0;  if(fan_bit3) {s13_dis(1); s14_dis(0);} else {s13_dis(0); s14_dis(1);} }
2601   2      
2602   2      
2603   2      
2604   2      
2605   2         if(dis_temp_bit)
2606   2          {
2607   3               dis_temp_bit=0;
2608   3               //----------------------------------------------------------------------------
2609   3           tm1=Temperature_LPF(0);
2610   3           tm1 =get_temperature(tm1); 
2611   3               temp1 =(int)tm1;
2612   3               if(tm1>=0)  t1_work_bit=1;  else  {t1_work_bit=0; out1=1; led6=1;}
2613   3                              
2614   3               tm2=Temperature_LPF(1);
2615   3           tm2 =get_temperature(tm2); 
2616   3               temp2 =(int)tm2;
2617   3               if(tm2>=0)  t2_work_bit=1;     else  {t2_work_bit=0; out2=1; led4=1;}
2618   3      
2619   3               tm3=Temperature_LPF(2);
2620   3           tm3 =get_temperature(tm3); 
2621   3               temp3 =(int)tm3;
2622   3               if(tm3>=0)  t3_work_bit=1;     else  {t3_work_bit=0; out3=1; led2=1;}
2623   3      
2624   3               tm4=Temperature_LPF(3);
2625   3           tm4 =get_temperature(tm4); 
2626   3               temp4 =(int)tm4;
2627   3               if(tm4>=0)  t4_work_bit=1;     else  {t4_work_bit=0; out4=1; led5=1;}
2628   3      
2629   3      
2630   3               //----------------------------------------------------------------------------------------------------
2631   3        if(hot_power==0)
2632   3         {     
2633   4               if(t1_work_bit)
2634   4              {                                                  
2635   5               if(temp1<=(temp_set1-2))                             {led6=0; out1=0; tm1_on_bit=0; tmp_cnt1=0;}
2636   5               else if((temp1>(temp_set1-2))&&(temp1<temp_set1))    {tm1_on_bit=1; tm1_pwm=PID1(temp_set1,temp1);}
2637   5               else if(temp1>temp_set1)                                     {led6=1; out1=1; tm1_on_bit=0; tmp_cnt1=0;}
2638   5              }                                                                                                                                          
2639   4               //----------------------------------------------------------------------------------------------------
2640   4               if(t2_work_bit)
2641   4              {                                                  
2642   5               if(temp2<=(temp_set2-2))                             {led4=0; out2=0; tm2_on_bit=0; tmp_cnt2=0;}
2643   5               else if((temp2>(temp_set2-2))&&(temp2<temp_set2))    {tm2_on_bit=1; tm2_pwm=PID2(temp_set2,temp2);}
2644   5               else if(temp2>temp_set2)                                     {led4=1; out2=1; tm2_on_bit=0; tmp_cnt2=0;}
2645   5              }
2646   4               //------------------------------------------------------------------------------------------------------
2647   4               if(t3_work_bit)
2648   4              {                                                  
2649   5               if(temp3<=(temp_set3-2))                             {led2=0; out3=0; tm3_on_bit=0; tmp_cnt3=0;}
2650   5               else if((temp3>(temp_set3-2))&&(temp3<temp_set3))    {tm3_on_bit=1; tm3_pwm=PID3(temp_set3,temp3);}
2651   5               else if(temp3>temp_set3)                                     {led2=1; out3=1; tm3_on_bit=0; tmp_cnt3=0;}
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 44  

2652   5              }
2653   4              
2654   4              //-------------------------------------------------------------------------------------------------------
2655   4               if(t4_work_bit)
2656   4              {                                                  
2657   5               if(temp4<=(temp_set4-2))                             {led5=0; out4=0; tm4_on_bit=0; tmp_cnt4=0;}
2658   5               else if((temp4>(temp_set4-2))&&(temp4<temp_set4))    {tm4_on_bit=1; tm4_pwm=PID4(temp_set4,temp4);}
2659   5               else if(temp4>temp_set4)                                     {led5=1; out4=1; tm4_on_bit=0; tmp_cnt4=0;}
2660   5              }
2661   4         }             
2662   3        }      
2663   2      
2664   2      
2665   2      
2666   2      
2667   2      
2668   2         if(hot_HT_bit) 
2669   2            {
2670   3                 hot_HT_bit=0;                
2671   3                 
2672   3                 switch(temp_num)      
2673   3                {
2674   4      
2675   4                  case 1: { dis1(1,tm1); H1_dis(0); f_dis(1); r_dis(0); m_dis(0); if(led6==0) hot_dis(1); else h
             -ot_dis(0);}break;
2676   4      
2677   4                  case 2: { dis1(1,tm2); f_dis(0); r_dis(0); m_dis(1); if(led4==0) hot_dis(1); else hot_dis(0);}
             -break;
2678   4      
2679   4                  case 3: { dis1(1,tm3); f_dis(0); r_dis(1); m_dis(0); if(led2==0) hot_dis(1); else hot_dis(0);}
             -break;
2680   4      
2681   4                              case 4: { dis1(1,tm4);  H1_dis(1);  if(led5==0) hot_dis(1); else hot_dis(0);}break;
2682   4                }   
2683   3      
2684   3             temp_num++;
2685   3                 if(temp_num>4)  temp_num=1; 
2686   3                } 
2687   2         
2688   2              else  {
2689   3                              switch(temp_num-1)       
2690   3                  {
2691   4      
2692   4                    case 1: { dis1(1,tm1); }break;
2693   4      
2694   4                    case 2: { dis1(1,tm2); }break;
2695   4      
2696   4                    case 3: { dis1(1,tm3); }break;
2697   4                        
2698   4                            case 4: { dis1(1,tm4); }break;
2699   4                    
2700   4                   } 
2701   3      
2702   3                    }
2703   2      
2704   2      
2705   2      
2706   2      
2707   2      
2708   2                                              
2709   2         
2710   2         if(save_bit) {save_bit=0; temp_num=1; save_mode_wr(); temp_set_bit=0; hot_HT_bit=1;  
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 45  

2711   3         
2712   3                                        temp_set1=(int)tm_set1;
2713   3                        temp_set2=(int)tm_set2;
2714   3                        temp_set3=(int)tm_set3;
2715   3                                    temp_set4=(int)tm_set4;
2716   3         
2717   3                      }
2718   2      
2719   2         if(hot_power_bit)  
2720   2         {
2721   3              hot_power_bit=0;
2722   3              if(hot_power==0)        
2723   3                                             {
2724   4                                                   led5=1;
2725   4                                                       hot_power=1;
2726   4                                                       TM1722_Write_Word(1,0);
2727   4                                                       TM1722_Write_Word(2,15);
2728   4                                                       TM1722_Write_Word(3,15);
2729   4                                                       led6=led4=led2=1;
2730   4                                                       out1=out2=out3=1;
2731   4                                                       hot_power_save();
2732   4                                                       Delay1ms(600);
2733   4                                                 }
2734   3                                         else  {
2735   4                                                         hot_power=0;         
2736   4                                                         led5=0;
2737   4                                                         hot_power_save();
2738   4                                                         TM1722_Write_Word(1,17);
2739   4                                                         TM1722_Write_Word(2,17);
2740   4                                                         TM1722_Write_Word(3,17);
2741   4                                                         Delay1ms(300);
2742   4                                                }
2743   3         }
2744   2      
2745   2      
2746   2         if(mode_num_bit)     
2747   2          {
2748   3               mode_num_bit=0;
2749   3               speak=sp_bit=0; 
2750   3               fan_bit=0; auto_bit=0; temp_set_bit=1; save_cnt=0;  mode_chose(); save_mode_num(); fan_run_stop(fan_num)
             -;  
2751   3                                temp_set1=(int)tm_set1;
2752   3                    temp_set2=(int)tm_set2;
2753   3                    temp_set3=(int)tm_set3;
2754   3                                temp_set4=(int)tm_set4;
2755   3              }
2756   2      
2757   2      
2758   2      
2759   2         if(key_buf==power_key)  
2760   2            {
2761   3                  t_cnt=30;
2762   3                                  
2763   3              while((key_buf==power_key)&&(t_cnt>0)) {t_cnt--; Delay1ms(10);}
2764   3                  if(t_cnt==0) 
2765   3                                    {
2766   4                                         speak=sp_bit=0;
2767   4                                         while(key_buf==power_key) WDT_CONTR=0X34;
2768   4      
2769   4                                         if(hot_power==0)     
2770   4                                             {
2771   5                                                   led5=1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 46  

2772   5                                                       hot_power=1;
2773   5                                                       TM1722_Write_Word(1,0);
2774   5                                                       TM1722_Write_Word(2,15);
2775   5                                                       TM1722_Write_Word(3,15);
2776   5                                                       led6=led4=led2=1;
2777   5                                                       out1=out2=out3=1;
2778   5                                                       hot_power_save();
2779   5                                                       Delay1ms(600);
2780   5                                                 }
2781   4                                         else  {
2782   5                                                         hot_power=0;         
2783   5                                                         led5=0;
2784   5                                                         hot_power_save();
2785   5                                                         TM1722_Write_Word(1,17);
2786   5                                                         TM1722_Write_Word(2,17);
2787   5                                                         TM1722_Write_Word(3,17);
2788   5                                                         Delay1ms(300);
2789   5                                                }
2790   4                                        }
2791   3                }
2792   2      
2793   2      
2794   2               
2795   2              if(key_buf==fn_key)      {      /*
2796   3                                        speak=sp_bit=0; 
2797   3                                                                
2798   3                                        if(fan_rs_bit) {fan_rs_bit=0; fan_stop();  fan_bit=0; fan_power=1;} 
2799   3      
2800   3                                                                else  {fan_rs_bit=1;fan_run_stop(fan_num); fan_power=0;}
2801   3      
2802   3                                                                fan_power_save();     */
2803   3      
2804   3                                        while(key_buf==fn_key) WDT_CONTR=0X34; 
2805   3                                                               }
2806   2      
2807   2      
2808   2          //风力加
2809   2         if(key_buf==up_key)      {speak=sp_bit=0; temp_set_bit=1; save_cnt=0; fan_num++; if(fan_num>6)   fan_nu
             -m=6;     fan_dis(fan_num); if((tb_num==0)||((tb_num==1)&&(hot_in==0))) fan_run_stop(fan_num); while(key_buf==up_key) WDT
             -_CONTR=0X34;}
2810   2      
2811   2         //风力减
2812   2         else if(key_buf==dn_key) {speak=sp_bit=0; temp_set_bit=1; save_cnt=0; if(fan_num==0) fan_num=0; else fa
             -n_num--; fan_dis(fan_num);    if((tb_num==0)||((tb_num==1)&&(hot_in==0))) fan_run_stop(fan_num); while(key_buf==dn_key) WDT
             -_CONTR=0X34;}
2813   2      
2814   2              
2815   2      
2816   2      
2817   2         
2818   2         if(key_buf==mode_key)  
2819   2          {
2820   3               t_cnt=150;
2821   3                                  
2822   3            while((key_buf==mode_key)&&(t_cnt>0)) {t_cnt--; Delay1ms(10);}
2823   3                if(t_cnt==0)  
2824   3                                    {  /*
2825   4                                         speak=sp_bit=0;
2826   4      
2827   4                                         if(tb_num==0) {tb_num=1; tb_dis(1);}
2828   4      
2829   4                                         else          {tb_num=0; tb_dis(0);}
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 47  

2830   4      
2831   4                                         while(key_buf==mode_key) WDT_CONTR=0X34;
2832   4      
2833   4                                         
2834   4                                               */
2835   4                                         
2836   4                                        }
2837   3      
2838   3                 else { speak=sp_bit=0; fan_bit=0; auto_bit=0; temp_set_bit=1; save_cnt=0; mode_num+=1; if(mode_num>3) 
             -mode_num=1; mode_chose(); save_mode_num(); fan_run_stop(fan_num); while(key_buf==mode_key) WDT_CONTR=0X34; 
2839   4                                temp_set1=(int)tm_set1;
2840   4                    temp_set2=(int)tm_set2;
2841   4                    temp_set3=(int)tm_set3;
2842   4                       }
2843   3                               
2844   3              }
2845   2      
2846   2         
2847   2         
2848   2         
2849   2         if(key_buf==fd_key) 
2850   2           { 
2851   3                      temp_num=1;
2852   3                      speak=sp_bit=0; 
2853   3                      cur_dis(0);        
2854   3                      set_dis(1); 
2855   3                      temp_dis(1);
2856   3                      f_dis(1); m_dis(0); r_dis(0);
2857   3                      H1_dis(0); H2_dis(0); H3_dis(0);
2858   3                      dis1(1,tm_set1);
2859   3                      temp_set_bit=1;
2860   3                      save_cnt=0;
2861   3      
2862   3                      while(key_buf==fd_key) 
2863   3                                           {
2864   4                                                 WDT_CONTR=0X34;
2865   4      
2866   4                                                 if(ss_bit) dis1(1,tm_set1);  else dis1(0,tm_set1);
2867   4                                               }
2868   3                            
2869   3                       while(1)  //-------------------第一路温度设定-------------------------------------------
2870   3                                         {
2871   4                                                Delay1ms(30);
2872   4      
2873   4                                                if(save_bit) {temp_set1=(int)tm_set1; goto set_end;  }
2874   4      
2875   4                                                if(ss_bit) dis1(1,tm_set1);  else dis1(0,tm_set1);
2876   4      
2877   4                                                if(key_buf==up_key)         {save_cnt=0; speak=sp_bit=0; tm_set1+=1; if(tm_set1>200) tm_set1=200; d
             -is1(1,tm_set1); Delay1ms(150);}
2878   4      
2879   4         
2880   4                            else if(key_buf==dn_key)    {save_cnt=0; speak=sp_bit=0;  if(tm_set1<=0) tm_set1=0; 
             -else tm_set1-=1;  dis1(1,tm_set1); Delay1ms(150);}
2881   4      
2882   4      
2883   4                                                else if(key_buf==fd_key)        {save_cnt=0; speak=sp_bit=0; while(key_buf==fd_key) WDT_CONTR=0X34;  bre
             -ak;}
2884   4      
2885   4                                               }
2886   3      
2887   3                       temp_set1=(int)tm_set1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 48  

2888   3      
2889   3                       f_dis(0);
2890   3                       m_dis(1);
2891   3                       dis1(1,tm_set2);                  
2892   3                                                
2893   3                      while(1)  //-------------------第二路温度设定-------------------------------------------
2894   3                                         {
2895   4                                                Delay1ms(30);
2896   4      
2897   4                                                if(save_bit) {temp_set2=(int)tm_set2; goto set_end;  }
2898   4      
2899   4                                                if(ss_bit) dis1(1,tm_set2);  else dis1(0,tm_set2);
2900   4      
2901   4                                                if(key_buf==up_key)         {save_cnt=0; speak=sp_bit=0; tm_set2+=1; if(tm_set2>200) tm_set2=200; d
             -is1(1,tm_set2); Delay1ms(150);}
2902   4      
2903   4         
2904   4                            else if(key_buf==dn_key)    {save_cnt=0; speak=sp_bit=0; if(tm_set2<=0) tm_set2=0; e
             -lse tm_set2-=1;   dis1(1,tm_set2); Delay1ms(150);}
2905   4      
2906   4      
2907   4                                                else if(key_buf==fd_key)        {save_cnt=0; speak=sp_bit=0; while(key_buf==fd_key) WDT_CONTR=0X34;  bre
             -ak;}
2908   4      
2909   4                                               }                
2910   3                      temp_set2=(int)tm_set2;
2911   3      
2912   3                       m_dis(0);
2913   3                       r_dis(1);
2914   3                       dis1(1,tm_set3);                  
2915   3                                                
2916   3                      while(1)  //-------------------第三路温度设定-------------------------------------------
2917   3                                         {
2918   4                                                Delay1ms(30);
2919   4      
2920   4                                                if(save_bit) {temp_set3=(int)tm_set3; goto set_end;  }
2921   4      
2922   4                                                if(ss_bit) dis1(1,tm_set3);  else dis1(0,tm_set3);
2923   4      
2924   4                                                if(key_buf==up_key)         {save_cnt=0; speak=sp_bit=0; tm_set3+=1; if(tm_set3>200) tm_set3=200; d
             -is1(1,tm_set3); Delay1ms(150);}
2925   4      
2926   4         
2927   4                            else if(key_buf==dn_key)    {save_cnt=0; speak=sp_bit=0; if(tm_set3<=0) tm_set3=0; e
             -lse tm_set3-=1;   dis1(1,tm_set3); Delay1ms(150);}
2928   4      
2929   4      
2930   4                                                else if(key_buf==fd_key)        {save_cnt=0; speak=sp_bit=0; while(key_buf==fd_key) WDT_CONTR=0X34;  bre
             -ak;}
2931   4      
2932   4                                               }      
2933   3                                               
2934   3                 temp_set3=(int)tm_set3;      
2935   3      
2936   3                 
2937   3      
2938   3      
2939   3                 
2940   3                 set_end: nop; nop;
2941   3                 save_bit=0;                   
2942   3                 temp_num=1;                           
2943   3                 temp_set_bit=0;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:16:15 PAGE 49  

2944   3                 
2945   3                 f_dis(0);
2946   3                 m_dis(0);
2947   3                 r_dis(0); 
2948   3                 cur_dis(1);     
2949   3                 set_dis(0);
2950   3                 save_mode_wr();                                 
2951   3                }
2952   2          
2953   2         
2954   2       }
2955   1                          
2956   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8335    ----
   CONSTANT SIZE    =    260    ----
   XDATA SIZE       =     94      54
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =    161    ----
   BIT SIZE         =     41      23
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
